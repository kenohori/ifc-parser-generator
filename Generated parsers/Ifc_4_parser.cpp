#include "Ifc_parser.hpp"

Ifc *Ifc_schema::parse_ifc_object_definition(std::string &object_class, std::vector<std::string> &object_attributes) {

if (boost::iequals(object_class, "IfcActionRequest")) {
		Ifc_action_request *o = new Ifc_action_request();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcActor")) {
		Ifc_actor *o = new Ifc_actor();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->the_actor = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->the_actor);
if (boost::iequals(object_class, "IfcActorRole")) {
		Ifc_actor_role *o = new Ifc_actor_role();
		o->role = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcActuator")) {
		Ifc_actuator *o = new Ifc_actuator();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcActuatorType")) {
		Ifc_actuator_type *o = new Ifc_actuator_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAddress")) {
		Ifc_address *o = new Ifc_address();
		o->purpose = step_parser.parse_constant(object_attributes[%d]);
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcAdvancedBrep")) {
		Ifc_advanced_brep *o = new Ifc_advanced_brep();
		o->outer = (Ifc_closed_shell *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer);
if (boost::iequals(object_class, "IfcAdvancedBrepWithVoids")) {
		Ifc_advanced_brep_with_voids *o = new Ifc_advanced_brep_with_voids();
		o->outer = (Ifc_closed_shell *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->voids.push_back((Ifc_closed_shell *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->voids);
if (boost::iequals(object_class, "IfcAdvancedFace")) {
		Ifc_advanced_face *o = new Ifc_advanced_face();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->bounds.push_back((Ifc_face_bound *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->bounds);
		o->face_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->face_surface);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAirTerminal")) {
		Ifc_air_terminal *o = new Ifc_air_terminal();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAirTerminalBox")) {
		Ifc_air_terminal_box *o = new Ifc_air_terminal_box();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAirTerminalBoxType")) {
		Ifc_air_terminal_box_type *o = new Ifc_air_terminal_box_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAirTerminalType")) {
		Ifc_air_terminal_type *o = new Ifc_air_terminal_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAirToAirHeatRecovery")) {
		Ifc_air_to_air_heat_recovery *o = new Ifc_air_to_air_heat_recovery();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAirToAirHeatRecoveryType")) {
		Ifc_air_to_air_heat_recovery_type *o = new Ifc_air_to_air_heat_recovery_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAlarm")) {
		Ifc_alarm *o = new Ifc_alarm();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAlarmType")) {
		Ifc_alarm_type *o = new Ifc_alarm_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAnnotation")) {
		Ifc_annotation *o = new Ifc_annotation();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
if (boost::iequals(object_class, "IfcAnnotationFillArea")) {
		Ifc_annotation_fill_area *o = new Ifc_annotation_fill_area();
		o->outer_boundary = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer_boundary);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->inner_boundaries.push_back((Ifc_curve *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->inner_boundaries);
if (boost::iequals(object_class, "IfcApplication")) {
		Ifc_application *o = new Ifc_application();
		o->application_developer = (Ifc_organization *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->application_developer);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcAppliedValue")) {
		Ifc_applied_value *o = new Ifc_applied_value();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->applied_value = (Ifc_applied_value_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_value);
		o->unit_basis = (Ifc_measure_with_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit_basis);
		o->applicable_date = step_parser.parse_string(object_attributes[%d]);
		o->fixed_until_date = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->arithmetic_operator = step_parser.parse_constant(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->components.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->components);
if (boost::iequals(object_class, "IfcApproval")) {
		Ifc_approval *o = new Ifc_approval();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->time_of_approval = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->qualifier = step_parser.parse_string(object_attributes[%d]);
		o->requesting_approval = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->requesting_approval);
		o->giving_approval = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->giving_approval);
if (boost::iequals(object_class, "IfcApprovalRelationship")) {
		Ifc_approval_relationship *o = new Ifc_approval_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_approval = (Ifc_approval *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_approval);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_approvals.push_back((Ifc_approval *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_approvals);
if (boost::iequals(object_class, "IfcArbitraryClosedProfileDef")) {
		Ifc_arbitrary_closed_profile_def *o = new Ifc_arbitrary_closed_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->outer_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer_curve);
if (boost::iequals(object_class, "IfcArbitraryOpenProfileDef")) {
		Ifc_arbitrary_open_profile_def *o = new Ifc_arbitrary_open_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->curve = (Ifc_bounded_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->curve);
if (boost::iequals(object_class, "IfcArbitraryProfileDefWithVoids")) {
		Ifc_arbitrary_profile_def_with_voids *o = new Ifc_arbitrary_profile_def_with_voids();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->outer_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer_curve);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->inner_curves.push_back((Ifc_curve *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->inner_curves);
if (boost::iequals(object_class, "IfcAsset")) {
		Ifc_asset *o = new Ifc_asset();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->original_value = (Ifc_cost_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->original_value);
		o->current_value = (Ifc_cost_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->current_value);
		o->total_replacement_cost = (Ifc_cost_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->total_replacement_cost);
		o->owner = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner);
		o->user = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->user);
		o->responsible_person = (Ifc_person *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->responsible_person);
		o->incorporation_date = step_parser.parse_string(object_attributes[%d]);
		o->depreciated_value = (Ifc_cost_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->depreciated_value);
if (boost::iequals(object_class, "IfcAsymmetricIShapeProfileDef")) {
		Ifc_asymmetric_i_shape_profile_def *o = new Ifc_asymmetric_i_shape_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->bottom_flange_slope = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->top_flange_slope = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAudioVisualAppliance")) {
		Ifc_audio_visual_appliance *o = new Ifc_audio_visual_appliance();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAudioVisualApplianceType")) {
		Ifc_audio_visual_appliance_type *o = new Ifc_audio_visual_appliance_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcAxis1Placement")) {
		Ifc_axis_1_placement *o = new Ifc_axis_1_placement();
		o->location = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->location);
		o->axis = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis);
if (boost::iequals(object_class, "IfcAxis2Placement2D")) {
		Ifc_axis_2_placement_2_d *o = new Ifc_axis_2_placement_2_d();
		o->location = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->location);
		o->ref_direction = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->ref_direction);
if (boost::iequals(object_class, "IfcAxis2Placement3D")) {
		Ifc_axis_2_placement_3_d *o = new Ifc_axis_2_placement_3_d();
		o->location = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->location);
		o->axis = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis);
		o->ref_direction = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->ref_direction);
if (boost::iequals(object_class, "IfcBSplineCurve")) {
		Ifc_b_spline_curve *o = new Ifc_b_spline_curve();
		o->step_parser.parse_integer(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->control_points_list.push_back((Ifc_cartesian_point *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->control_points_list);
		o->curve_form = step_parser.parse_constant(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBSplineCurveWithKnots")) {
		Ifc_b_spline_curve_with_knots *o = new Ifc_b_spline_curve_with_knots();
		o->step_parser.parse_integer(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->control_points_list.push_back((Ifc_cartesian_point *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->control_points_list);
		o->curve_form = step_parser.parse_constant(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		o->knot_multiplicities = step_parser.parse_integer(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->knots.push_back((Ifc_parameter_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->knots);
		o->knot_spec = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBSplineSurface")) {
		Ifc_b_spline_surface *o = new Ifc_b_spline_surface();
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
				//TODO: parse container of container
		o->surface_form = step_parser.parse_constant(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBSplineSurfaceWithKnots")) {
		Ifc_b_spline_surface_with_knots *o = new Ifc_b_spline_surface_with_knots();
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
				//TODO: parse container of container
		o->surface_form = step_parser.parse_constant(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		o->u_multiplicities = step_parser.parse_integer(object_attributes[%d]);
		o->v_multiplicities = step_parser.parse_integer(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->u_knots.push_back((Ifc_parameter_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->u_knots);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->v_knots.push_back((Ifc_parameter_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->v_knots);
		o->knot_spec = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBeam")) {
		Ifc_beam *o = new Ifc_beam();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBeamStandardCase")) {
		Ifc_beam_standard_case *o = new Ifc_beam_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBeamType")) {
		Ifc_beam_type *o = new Ifc_beam_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBlobTexture")) {
		Ifc_blob_texture *o = new Ifc_blob_texture();
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->texture_transform = (Ifc_cartesian_transformation_operator_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->texture_transform);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->parameter.push_back((Ifc_identifier *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->parameter);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse other pod

if (boost::iequals(object_class, "IfcBlock")) {
		Ifc_block *o = new Ifc_block();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcBoiler")) {
		Ifc_boiler *o = new Ifc_boiler();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBoilerType")) {
		Ifc_boiler_type *o = new Ifc_boiler_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBooleanClippingResult")) {
		Ifc_boolean_clipping_result *o = new Ifc_boolean_clipping_result();
		o->operator = step_parser.parse_constant(object_attributes[%d]);
		o->first_operand = (Ifc_boolean_operand *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->first_operand);
		o->second_operand = (Ifc_boolean_operand *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->second_operand);
if (boost::iequals(object_class, "IfcBooleanResult")) {
		Ifc_boolean_result *o = new Ifc_boolean_result();
		o->operator = step_parser.parse_constant(object_attributes[%d]);
		o->first_operand = (Ifc_boolean_operand *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->first_operand);
		o->second_operand = (Ifc_boolean_operand *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->second_operand);
if (boost::iequals(object_class, "IfcBoundaryCondition")) {
		Ifc_boundary_condition *o = new Ifc_boundary_condition();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcBoundaryCurve")) {
		Ifc_boundary_curve *o = new Ifc_boundary_curve();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->segments.push_back((Ifc_composite_curve_segment *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->segments);
		//o->step_parser.parse_logical(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBoundaryEdgeCondition")) {
		Ifc_boundary_edge_condition *o = new Ifc_boundary_edge_condition();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->translational_stiffness_by_length_x = (Ifc_modulus_of_translational_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_by_length_x);
		o->translational_stiffness_by_length_y = (Ifc_modulus_of_translational_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_by_length_y);
		o->translational_stiffness_by_length_z = (Ifc_modulus_of_translational_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_by_length_z);
		o->rotational_stiffness_by_length_x = (Ifc_modulus_of_rotational_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_by_length_x);
		o->rotational_stiffness_by_length_y = (Ifc_modulus_of_rotational_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_by_length_y);
		o->rotational_stiffness_by_length_z = (Ifc_modulus_of_rotational_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_by_length_z);
if (boost::iequals(object_class, "IfcBoundaryFaceCondition")) {
		Ifc_boundary_face_condition *o = new Ifc_boundary_face_condition();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->translational_stiffness_by_area_x = (Ifc_modulus_of_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_by_area_x);
		o->translational_stiffness_by_area_y = (Ifc_modulus_of_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_by_area_y);
		o->translational_stiffness_by_area_z = (Ifc_modulus_of_subgrade_reaction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_by_area_z);
if (boost::iequals(object_class, "IfcBoundaryNodeCondition")) {
		Ifc_boundary_node_condition *o = new Ifc_boundary_node_condition();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->translational_stiffness_x = (Ifc_translational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_x);
		o->translational_stiffness_y = (Ifc_translational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_y);
		o->translational_stiffness_z = (Ifc_translational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_z);
		o->rotational_stiffness_x = (Ifc_rotational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_x);
		o->rotational_stiffness_y = (Ifc_rotational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_y);
		o->rotational_stiffness_z = (Ifc_rotational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_z);
if (boost::iequals(object_class, "IfcBoundaryNodeConditionWarping")) {
		Ifc_boundary_node_condition_warping *o = new Ifc_boundary_node_condition_warping();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->translational_stiffness_x = (Ifc_translational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_x);
		o->translational_stiffness_y = (Ifc_translational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_y);
		o->translational_stiffness_z = (Ifc_translational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->translational_stiffness_z);
		o->rotational_stiffness_x = (Ifc_rotational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_x);
		o->rotational_stiffness_y = (Ifc_rotational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_y);
		o->rotational_stiffness_z = (Ifc_rotational_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rotational_stiffness_z);
		o->warping_stiffness = (Ifc_warping_stiffness_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->warping_stiffness);
if (boost::iequals(object_class, "IfcBoundedCurve")) {
		Ifc_bounded_curve *o = new Ifc_bounded_curve();
if (boost::iequals(object_class, "IfcBoundedSurface")) {
		Ifc_bounded_surface *o = new Ifc_bounded_surface();
if (boost::iequals(object_class, "IfcBoundingBox")) {
		Ifc_bounding_box *o = new Ifc_bounding_box();
		o->corner = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->corner);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcBoxedHalfSpace")) {
		Ifc_boxed_half_space *o = new Ifc_boxed_half_space();
		o->base_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_surface);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->enclosure = (Ifc_bounding_box *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->enclosure);
if (boost::iequals(object_class, "IfcBuilding")) {
		Ifc_building *o = new Ifc_building();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->composition_type = step_parser.parse_constant(object_attributes[%d]);
		o->elevation_of_ref_height = step_parser.parse_double(object_attributes[%d]);
		o->elevation_of_terrain = step_parser.parse_double(object_attributes[%d]);
		o->building_address = (Ifc_postal_address *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->building_address);
if (boost::iequals(object_class, "IfcBuildingElement")) {
		Ifc_building_element *o = new Ifc_building_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcBuildingElementPart")) {
		Ifc_building_element_part *o = new Ifc_building_element_part();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBuildingElementPartType")) {
		Ifc_building_element_part_type *o = new Ifc_building_element_part_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBuildingElementProxy")) {
		Ifc_building_element_proxy *o = new Ifc_building_element_proxy();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBuildingElementProxyType")) {
		Ifc_building_element_proxy_type *o = new Ifc_building_element_proxy_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBuildingElementType")) {
		Ifc_building_element_type *o = new Ifc_building_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcBuildingStorey")) {
		Ifc_building_storey *o = new Ifc_building_storey();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->composition_type = step_parser.parse_constant(object_attributes[%d]);
		o->elevation = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBuildingSystem")) {
		Ifc_building_system *o = new Ifc_building_system();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBurner")) {
		Ifc_burner *o = new Ifc_burner();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcBurnerType")) {
		Ifc_burner_type *o = new Ifc_burner_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCShapeProfileDef")) {
		Ifc_c_shape_profile_def *o = new Ifc_c_shape_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
if (boost::iequals(object_class, "IfcCableCarrierFitting")) {
		Ifc_cable_carrier_fitting *o = new Ifc_cable_carrier_fitting();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCableCarrierFittingType")) {
		Ifc_cable_carrier_fitting_type *o = new Ifc_cable_carrier_fitting_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCableCarrierSegment")) {
		Ifc_cable_carrier_segment *o = new Ifc_cable_carrier_segment();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCableCarrierSegmentType")) {
		Ifc_cable_carrier_segment_type *o = new Ifc_cable_carrier_segment_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCableFitting")) {
		Ifc_cable_fitting *o = new Ifc_cable_fitting();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCableFittingType")) {
		Ifc_cable_fitting_type *o = new Ifc_cable_fitting_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCableSegment")) {
		Ifc_cable_segment *o = new Ifc_cable_segment();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCableSegmentType")) {
		Ifc_cable_segment_type *o = new Ifc_cable_segment_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCartesianPoint")) {
		Ifc_cartesian_point *o = new Ifc_cartesian_point();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->coordinates.push_back((Ifc_length_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->coordinates);
if (boost::iequals(object_class, "IfcCartesianPointList")) {
		Ifc_cartesian_point_list *o = new Ifc_cartesian_point_list();
if (boost::iequals(object_class, "IfcCartesianPointList3D")) {
		Ifc_cartesian_point_list_3_d *o = new Ifc_cartesian_point_list_3_d();
				//TODO: parse container of container
if (boost::iequals(object_class, "IfcCartesianTransformationOperator")) {
		Ifc_cartesian_transformation_operator *o = new Ifc_cartesian_transformation_operator();
		o->axis_1 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_1);
		o->axis_2 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_2);
		o->local_origin = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->local_origin);
		o->step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCartesianTransformationOperator2D")) {
		Ifc_cartesian_transformation_operator_2_d *o = new Ifc_cartesian_transformation_operator_2_d();
		o->axis_1 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_1);
		o->axis_2 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_2);
		o->local_origin = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->local_origin);
		o->step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCartesianTransformationOperator2DnonUniform")) {
		Ifc_cartesian_transformation_operator_2_dnon_uniform *o = new Ifc_cartesian_transformation_operator_2_dnon_uniform();
		o->axis_1 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_1);
		o->axis_2 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_2);
		o->local_origin = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->local_origin);
		o->step_parser.parse_double(object_attributes[%d]);
		o->step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCartesianTransformationOperator3D")) {
		Ifc_cartesian_transformation_operator_3_d *o = new Ifc_cartesian_transformation_operator_3_d();
		o->axis_1 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_1);
		o->axis_2 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_2);
		o->local_origin = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->local_origin);
		o->step_parser.parse_double(object_attributes[%d]);
		o->axis_3 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_3);
if (boost::iequals(object_class, "IfcCartesianTransformationOperator3DnonUniform")) {
		Ifc_cartesian_transformation_operator_3_dnon_uniform *o = new Ifc_cartesian_transformation_operator_3_dnon_uniform();
		o->axis_1 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_1);
		o->axis_2 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_2);
		o->local_origin = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->local_origin);
		o->step_parser.parse_double(object_attributes[%d]);
		o->axis_3 = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_3);
		o->step_parser.parse_double(object_attributes[%d]);
		o->step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCenterLineProfileDef")) {
		Ifc_center_line_profile_def *o = new Ifc_center_line_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->curve = (Ifc_bounded_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->curve);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcChiller")) {
		Ifc_chiller *o = new Ifc_chiller();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcChillerType")) {
		Ifc_chiller_type *o = new Ifc_chiller_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcChimney")) {
		Ifc_chimney *o = new Ifc_chimney();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcChimneyType")) {
		Ifc_chimney_type *o = new Ifc_chimney_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCircle")) {
		Ifc_circle *o = new Ifc_circle();
		o->position = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcCircleHollowProfileDef")) {
		Ifc_circle_hollow_profile_def *o = new Ifc_circle_hollow_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcCircleProfileDef")) {
		Ifc_circle_profile_def *o = new Ifc_circle_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcCivilElement")) {
		Ifc_civil_element *o = new Ifc_civil_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcCivilElementType")) {
		Ifc_civil_element_type *o = new Ifc_civil_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcClassification")) {
		Ifc_classification *o = new Ifc_classification();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->edition_date = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->location = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->reference_tokens.push_back((Ifc_identifier *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->reference_tokens);
if (boost::iequals(object_class, "IfcClassificationReference")) {
		Ifc_classification_reference *o = new Ifc_classification_reference();
		o->location = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->referenced_source = (Ifc_classification_reference_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->referenced_source);
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcClosedShell")) {
		Ifc_closed_shell *o = new Ifc_closed_shell();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->cfs_faces.push_back((Ifc_face *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->cfs_faces);
if (boost::iequals(object_class, "IfcCoil")) {
		Ifc_coil *o = new Ifc_coil();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCoilType")) {
		Ifc_coil_type *o = new Ifc_coil_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcColourRgb")) {
		Ifc_colour_rgb *o = new Ifc_colour_rgb();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
if (boost::iequals(object_class, "IfcColourRgbList")) {
		Ifc_colour_rgb_list *o = new Ifc_colour_rgb_list();
				//TODO: parse container of container
if (boost::iequals(object_class, "IfcColourSpecification")) {
		Ifc_colour_specification *o = new Ifc_colour_specification();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcColumn")) {
		Ifc_column *o = new Ifc_column();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcColumnStandardCase")) {
		Ifc_column_standard_case *o = new Ifc_column_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcColumnType")) {
		Ifc_column_type *o = new Ifc_column_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCommunicationsAppliance")) {
		Ifc_communications_appliance *o = new Ifc_communications_appliance();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCommunicationsApplianceType")) {
		Ifc_communications_appliance_type *o = new Ifc_communications_appliance_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcComplexProperty")) {
		Ifc_complex_property *o = new Ifc_complex_property();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_properties.push_back((Ifc_property *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_properties);
if (boost::iequals(object_class, "IfcComplexPropertyTemplate")) {
		Ifc_complex_property_template *o = new Ifc_complex_property_template();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->template_type = step_parser.parse_constant(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_templates.push_back((Ifc_property_template *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_templates);
if (boost::iequals(object_class, "IfcCompositeCurve")) {
		Ifc_composite_curve *o = new Ifc_composite_curve();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->segments.push_back((Ifc_composite_curve_segment *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->segments);
		//o->step_parser.parse_logical(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCompositeCurveOnSurface")) {
		Ifc_composite_curve_on_surface *o = new Ifc_composite_curve_on_surface();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->segments.push_back((Ifc_composite_curve_segment *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->segments);
		//o->step_parser.parse_logical(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCompositeCurveSegment")) {
		Ifc_composite_curve_segment *o = new Ifc_composite_curve_segment();
		o->transition = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->parent_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->parent_curve);
if (boost::iequals(object_class, "IfcCompositeProfileDef")) {
		Ifc_composite_profile_def *o = new Ifc_composite_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->profiles.push_back((Ifc_profile_def *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->profiles);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcCompressor")) {
		Ifc_compressor *o = new Ifc_compressor();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCompressorType")) {
		Ifc_compressor_type *o = new Ifc_compressor_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCondenser")) {
		Ifc_condenser *o = new Ifc_condenser();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCondenserType")) {
		Ifc_condenser_type *o = new Ifc_condenser_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConic")) {
		Ifc_conic *o = new Ifc_conic();
		o->position = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
if (boost::iequals(object_class, "IfcConnectedFaceSet")) {
		Ifc_connected_face_set *o = new Ifc_connected_face_set();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->cfs_faces.push_back((Ifc_face *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->cfs_faces);
if (boost::iequals(object_class, "IfcConnectionCurveGeometry")) {
		Ifc_connection_curve_geometry *o = new Ifc_connection_curve_geometry();
		o->curve_on_relating_element = (Ifc_curve_or_edge_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->curve_on_relating_element);
		o->curve_on_related_element = (Ifc_curve_or_edge_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->curve_on_related_element);
if (boost::iequals(object_class, "IfcConnectionGeometry")) {
		Ifc_connection_geometry *o = new Ifc_connection_geometry();
if (boost::iequals(object_class, "IfcConnectionPointEccentricity")) {
		Ifc_connection_point_eccentricity *o = new Ifc_connection_point_eccentricity();
		o->point_on_relating_element = (Ifc_point_or_vertex_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->point_on_relating_element);
		o->point_on_related_element = (Ifc_point_or_vertex_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->point_on_related_element);
		o->eccentricity_in_x = step_parser.parse_double(object_attributes[%d]);
		o->eccentricity_in_y = step_parser.parse_double(object_attributes[%d]);
		o->eccentricity_in_z = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConnectionPointGeometry")) {
		Ifc_connection_point_geometry *o = new Ifc_connection_point_geometry();
		o->point_on_relating_element = (Ifc_point_or_vertex_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->point_on_relating_element);
		o->point_on_related_element = (Ifc_point_or_vertex_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->point_on_related_element);
if (boost::iequals(object_class, "IfcConnectionSurfaceGeometry")) {
		Ifc_connection_surface_geometry *o = new Ifc_connection_surface_geometry();
		o->surface_on_relating_element = (Ifc_surface_or_face_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->surface_on_relating_element);
		o->surface_on_related_element = (Ifc_surface_or_face_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->surface_on_related_element);
if (boost::iequals(object_class, "IfcConnectionVolumeGeometry")) {
		Ifc_connection_volume_geometry *o = new Ifc_connection_volume_geometry();
		o->volume_on_relating_element = (Ifc_solid_or_shell *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->volume_on_relating_element);
		o->volume_on_related_element = (Ifc_solid_or_shell *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->volume_on_related_element);
if (boost::iequals(object_class, "IfcConstraint")) {
		Ifc_constraint *o = new Ifc_constraint();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->constraint_grade = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->creating_actor = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->creating_actor);
		o->creation_time = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcConstructionEquipmentResource")) {
		Ifc_construction_equipment_resource *o = new Ifc_construction_equipment_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->usage = (Ifc_resource_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->usage);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConstructionEquipmentResourceType")) {
		Ifc_construction_equipment_resource_type *o = new Ifc_construction_equipment_resource_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConstructionMaterialResource")) {
		Ifc_construction_material_resource *o = new Ifc_construction_material_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->usage = (Ifc_resource_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->usage);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConstructionMaterialResourceType")) {
		Ifc_construction_material_resource_type *o = new Ifc_construction_material_resource_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConstructionProductResource")) {
		Ifc_construction_product_resource *o = new Ifc_construction_product_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->usage = (Ifc_resource_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->usage);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConstructionProductResourceType")) {
		Ifc_construction_product_resource_type *o = new Ifc_construction_product_resource_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConstructionResource")) {
		Ifc_construction_resource *o = new Ifc_construction_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->usage = (Ifc_resource_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->usage);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
if (boost::iequals(object_class, "IfcConstructionResourceType")) {
		Ifc_construction_resource_type *o = new Ifc_construction_resource_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
if (boost::iequals(object_class, "IfcContext")) {
		Ifc_context *o = new Ifc_context();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_contexts.push_back((Ifc_representation_context *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_contexts);
		o->units_in_context = (Ifc_unit_assignment *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->units_in_context);
if (boost::iequals(object_class, "IfcContextDependentUnit")) {
		Ifc_context_dependent_unit *o = new Ifc_context_dependent_unit();
		o->dimensions = (Ifc_dimensional_exponents *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->dimensions);
		o->unit_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcControl")) {
		Ifc_control *o = new Ifc_control();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcController")) {
		Ifc_controller *o = new Ifc_controller();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcControllerType")) {
		Ifc_controller_type *o = new Ifc_controller_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcConversionBasedUnit")) {
		Ifc_conversion_based_unit *o = new Ifc_conversion_based_unit();
		o->dimensions = (Ifc_dimensional_exponents *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->dimensions);
		o->unit_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->conversion_factor = (Ifc_measure_with_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->conversion_factor);
if (boost::iequals(object_class, "IfcConversionBasedUnitWithOffset")) {
		Ifc_conversion_based_unit_with_offset *o = new Ifc_conversion_based_unit_with_offset();
		o->dimensions = (Ifc_dimensional_exponents *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->dimensions);
		o->unit_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->conversion_factor = (Ifc_measure_with_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->conversion_factor);
		o->conversion_offset = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCooledBeam")) {
		Ifc_cooled_beam *o = new Ifc_cooled_beam();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCooledBeamType")) {
		Ifc_cooled_beam_type *o = new Ifc_cooled_beam_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCoolingTower")) {
		Ifc_cooling_tower *o = new Ifc_cooling_tower();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCoolingTowerType")) {
		Ifc_cooling_tower_type *o = new Ifc_cooling_tower_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCoordinateOperation")) {
		Ifc_coordinate_operation *o = new Ifc_coordinate_operation();
		o->source_c_r_s = (Ifc_coordinate_reference_system_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->source_c_r_s);
		o->target_c_r_s = (Ifc_coordinate_reference_system *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->target_c_r_s);
if (boost::iequals(object_class, "IfcCoordinateReferenceSystem")) {
		Ifc_coordinate_reference_system *o = new Ifc_coordinate_reference_system();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcCostItem")) {
		Ifc_cost_item *o = new Ifc_cost_item();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->cost_values.push_back((Ifc_cost_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->cost_values);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->cost_quantities.push_back((Ifc_physical_quantity *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->cost_quantities);
if (boost::iequals(object_class, "IfcCostSchedule")) {
		Ifc_cost_schedule *o = new Ifc_cost_schedule();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->submitted_on = step_parser.parse_string(object_attributes[%d]);
		o->update_date = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCostValue")) {
		Ifc_cost_value *o = new Ifc_cost_value();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->applied_value = (Ifc_applied_value_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_value);
		o->unit_basis = (Ifc_measure_with_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit_basis);
		o->applicable_date = step_parser.parse_string(object_attributes[%d]);
		o->fixed_until_date = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->arithmetic_operator = step_parser.parse_constant(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->components.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->components);
if (boost::iequals(object_class, "IfcCovering")) {
		Ifc_covering *o = new Ifc_covering();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCoveringType")) {
		Ifc_covering_type *o = new Ifc_covering_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCrewResource")) {
		Ifc_crew_resource *o = new Ifc_crew_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->usage = (Ifc_resource_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->usage);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCrewResourceType")) {
		Ifc_crew_resource_type *o = new Ifc_crew_resource_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCsgPrimitive3D")) {
		Ifc_csg_primitive_3_d *o = new Ifc_csg_primitive_3_d();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
if (boost::iequals(object_class, "IfcCsgSolid")) {
		Ifc_csg_solid *o = new Ifc_csg_solid();
		o->tree_root_expression = (Ifc_csg_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->tree_root_expression);
if (boost::iequals(object_class, "IfcCurrencyRelationship")) {
		Ifc_currency_relationship *o = new Ifc_currency_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_monetary_unit = (Ifc_monetary_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_monetary_unit);
		o->related_monetary_unit = (Ifc_monetary_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_monetary_unit);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
		o->rate_date_time = step_parser.parse_string(object_attributes[%d]);
		o->rate_source = (Ifc_library_information *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->rate_source);
if (boost::iequals(object_class, "IfcCurtainWall")) {
		Ifc_curtain_wall *o = new Ifc_curtain_wall();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCurtainWallType")) {
		Ifc_curtain_wall_type *o = new Ifc_curtain_wall_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCurve")) {
		Ifc_curve *o = new Ifc_curve();
if (boost::iequals(object_class, "IfcCurveBoundedPlane")) {
		Ifc_curve_bounded_plane *o = new Ifc_curve_bounded_plane();
		o->basis_surface = (Ifc_plane *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_surface);
		o->outer_boundary = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer_boundary);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->inner_boundaries.push_back((Ifc_curve *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->inner_boundaries);
if (boost::iequals(object_class, "IfcCurveBoundedSurface")) {
		Ifc_curve_bounded_surface *o = new Ifc_curve_bounded_surface();
		o->basis_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_surface);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->boundaries.push_back((Ifc_boundary_curve *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->boundaries);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCurveStyle")) {
		Ifc_curve_style *o = new Ifc_curve_style();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->curve_font = (Ifc_curve_font_or_scaled_curve_font_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->curve_font);
		o->curve_width = (Ifc_size_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->curve_width);
		o->curve_colour = (Ifc_colour *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->curve_colour);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcCurveStyleFont")) {
		Ifc_curve_style_font *o = new Ifc_curve_style_font();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->pattern_list.push_back((Ifc_curve_style_font_pattern *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->pattern_list);
if (boost::iequals(object_class, "IfcCurveStyleFontAndScaling")) {
		Ifc_curve_style_font_and_scaling *o = new Ifc_curve_style_font_and_scaling();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->curve_font = (Ifc_curve_style_font_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->curve_font);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
if (boost::iequals(object_class, "IfcCurveStyleFontPattern")) {
		Ifc_curve_style_font_pattern *o = new Ifc_curve_style_font_pattern();
		o->visible_segment_length = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcCylindricalSurface")) {
		Ifc_cylindrical_surface *o = new Ifc_cylindrical_surface();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcDamper")) {
		Ifc_damper *o = new Ifc_damper();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDamperType")) {
		Ifc_damper_type *o = new Ifc_damper_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDerivedProfileDef")) {
		Ifc_derived_profile_def *o = new Ifc_derived_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->parent_profile = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->parent_profile);
		o->operator = (Ifc_cartesian_transformation_operator_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->operator);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDerivedUnit")) {
		Ifc_derived_unit *o = new Ifc_derived_unit();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->elements.push_back((Ifc_derived_unit_element *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->elements);
		o->unit_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDerivedUnitElement")) {
		Ifc_derived_unit_element *o = new Ifc_derived_unit_element();
		o->unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->step_parser.parse_integer(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDimensionalExponents")) {
		Ifc_dimensional_exponents *o = new Ifc_dimensional_exponents();
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDirection")) {
		Ifc_direction *o = new Ifc_direction();
		o->direction_ratios = step_parser.parse_list_of_doubles(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDiscreteAccessory")) {
		Ifc_discrete_accessory *o = new Ifc_discrete_accessory();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDiscreteAccessoryType")) {
		Ifc_discrete_accessory_type *o = new Ifc_discrete_accessory_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDistributionChamberElement")) {
		Ifc_distribution_chamber_element *o = new Ifc_distribution_chamber_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDistributionChamberElementType")) {
		Ifc_distribution_chamber_element_type *o = new Ifc_distribution_chamber_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDistributionCircuit")) {
		Ifc_distribution_circuit *o = new Ifc_distribution_circuit();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDistributionControlElement")) {
		Ifc_distribution_control_element *o = new Ifc_distribution_control_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcDistributionControlElementType")) {
		Ifc_distribution_control_element_type *o = new Ifc_distribution_control_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDistributionElement")) {
		Ifc_distribution_element *o = new Ifc_distribution_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcDistributionElementType")) {
		Ifc_distribution_element_type *o = new Ifc_distribution_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDistributionFlowElement")) {
		Ifc_distribution_flow_element *o = new Ifc_distribution_flow_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcDistributionFlowElementType")) {
		Ifc_distribution_flow_element_type *o = new Ifc_distribution_flow_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDistributionPort")) {
		Ifc_distribution_port *o = new Ifc_distribution_port();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->flow_direction = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->system_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDistributionSystem")) {
		Ifc_distribution_system *o = new Ifc_distribution_system();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDocumentInformation")) {
		Ifc_document_information *o = new Ifc_document_information();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->location = step_parser.parse_string(object_attributes[%d]);
		o->purpose = step_parser.parse_string(object_attributes[%d]);
		o->intended_use = step_parser.parse_string(object_attributes[%d]);
		o->scope = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->document_owner = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->document_owner);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->editors.push_back((Ifc_actor_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->editors);
		o->creation_time = step_parser.parse_string(object_attributes[%d]);
		o->last_revision_time = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->valid_from = step_parser.parse_string(object_attributes[%d]);
		o->valid_until = step_parser.parse_string(object_attributes[%d]);
		o->confidentiality = step_parser.parse_constant(object_attributes[%d]);
		o->status = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDocumentInformationRelationship")) {
		Ifc_document_information_relationship *o = new Ifc_document_information_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_document = (Ifc_document_information *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_document);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_documents.push_back((Ifc_document_information *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_documents);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDocumentReference")) {
		Ifc_document_reference *o = new Ifc_document_reference();
		o->location = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->referenced_document = (Ifc_document_information *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->referenced_document);
if (boost::iequals(object_class, "IfcDoor")) {
		Ifc_door *o = new Ifc_door();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->operation_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDoorLiningProperties")) {
		Ifc_door_lining_properties *o = new Ifc_door_lining_properties();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->transom_offset = step_parser.parse_double(object_attributes[%d]);
		o->lining_offset = step_parser.parse_double(object_attributes[%d]);
		o->threshold_offset = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->shape_aspect_style = (Ifc_shape_aspect *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->shape_aspect_style);
		o->lining_to_panel_offset_x = step_parser.parse_double(object_attributes[%d]);
		o->lining_to_panel_offset_y = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDoorPanelProperties")) {
		Ifc_door_panel_properties *o = new Ifc_door_panel_properties();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->panel_operation = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		o->panel_position = step_parser.parse_constant(object_attributes[%d]);
		o->shape_aspect_style = (Ifc_shape_aspect *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->shape_aspect_style);
if (boost::iequals(object_class, "IfcDoorStandardCase")) {
		Ifc_door_standard_case *o = new Ifc_door_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->operation_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDoorStyle")) {
		Ifc_door_style *o = new Ifc_door_style();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->operation_type = step_parser.parse_constant(object_attributes[%d]);
		o->construction_type = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDoorType")) {
		Ifc_door_type *o = new Ifc_door_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->operation_type = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDraughtingPreDefinedColour")) {
		Ifc_draughting_pre_defined_colour *o = new Ifc_draughting_pre_defined_colour();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDraughtingPreDefinedCurveFont")) {
		Ifc_draughting_pre_defined_curve_font *o = new Ifc_draughting_pre_defined_curve_font();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcDuctFitting")) {
		Ifc_duct_fitting *o = new Ifc_duct_fitting();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDuctFittingType")) {
		Ifc_duct_fitting_type *o = new Ifc_duct_fitting_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDuctSegment")) {
		Ifc_duct_segment *o = new Ifc_duct_segment();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDuctSegmentType")) {
		Ifc_duct_segment_type *o = new Ifc_duct_segment_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDuctSilencer")) {
		Ifc_duct_silencer *o = new Ifc_duct_silencer();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcDuctSilencerType")) {
		Ifc_duct_silencer_type *o = new Ifc_duct_silencer_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEdge")) {
		Ifc_edge *o = new Ifc_edge();
		o->edge_start = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_start);
		o->edge_end = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_end);
if (boost::iequals(object_class, "IfcEdgeCurve")) {
		Ifc_edge_curve *o = new Ifc_edge_curve();
		o->edge_start = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_start);
		o->edge_end = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_end);
		o->edge_geometry = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_geometry);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEdgeLoop")) {
		Ifc_edge_loop *o = new Ifc_edge_loop();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->edge_list.push_back((Ifc_oriented_edge *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->edge_list);
if (boost::iequals(object_class, "IfcElectricAppliance")) {
		Ifc_electric_appliance *o = new Ifc_electric_appliance();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricApplianceType")) {
		Ifc_electric_appliance_type *o = new Ifc_electric_appliance_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricDistributionBoard")) {
		Ifc_electric_distribution_board *o = new Ifc_electric_distribution_board();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricDistributionBoardType")) {
		Ifc_electric_distribution_board_type *o = new Ifc_electric_distribution_board_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricFlowStorageDevice")) {
		Ifc_electric_flow_storage_device *o = new Ifc_electric_flow_storage_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricFlowStorageDeviceType")) {
		Ifc_electric_flow_storage_device_type *o = new Ifc_electric_flow_storage_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricGenerator")) {
		Ifc_electric_generator *o = new Ifc_electric_generator();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricGeneratorType")) {
		Ifc_electric_generator_type *o = new Ifc_electric_generator_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricMotor")) {
		Ifc_electric_motor *o = new Ifc_electric_motor();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricMotorType")) {
		Ifc_electric_motor_type *o = new Ifc_electric_motor_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricTimeControl")) {
		Ifc_electric_time_control *o = new Ifc_electric_time_control();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElectricTimeControlType")) {
		Ifc_electric_time_control_type *o = new Ifc_electric_time_control_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElement")) {
		Ifc_element *o = new Ifc_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcElementAssembly")) {
		Ifc_element_assembly *o = new Ifc_element_assembly();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->assembly_place = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElementAssemblyType")) {
		Ifc_element_assembly_type *o = new Ifc_element_assembly_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcElementComponent")) {
		Ifc_element_component *o = new Ifc_element_component();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcElementComponentType")) {
		Ifc_element_component_type *o = new Ifc_element_component_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcElementQuantity")) {
		Ifc_element_quantity *o = new Ifc_element_quantity();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->quantities.push_back((Ifc_physical_quantity *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->quantities);
if (boost::iequals(object_class, "IfcElementType")) {
		Ifc_element_type *o = new Ifc_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcElementarySurface")) {
		Ifc_elementary_surface *o = new Ifc_elementary_surface();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
if (boost::iequals(object_class, "IfcEllipse")) {
		Ifc_ellipse *o = new Ifc_ellipse();
		o->position = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcEllipseProfileDef")) {
		Ifc_ellipse_profile_def *o = new Ifc_ellipse_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcEnergyConversionDevice")) {
		Ifc_energy_conversion_device *o = new Ifc_energy_conversion_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcEnergyConversionDeviceType")) {
		Ifc_energy_conversion_device_type *o = new Ifc_energy_conversion_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcEngine")) {
		Ifc_engine *o = new Ifc_engine();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEngineType")) {
		Ifc_engine_type *o = new Ifc_engine_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEvaporativeCooler")) {
		Ifc_evaporative_cooler *o = new Ifc_evaporative_cooler();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEvaporativeCoolerType")) {
		Ifc_evaporative_cooler_type *o = new Ifc_evaporative_cooler_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEvaporator")) {
		Ifc_evaporator *o = new Ifc_evaporator();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEvaporatorType")) {
		Ifc_evaporator_type *o = new Ifc_evaporator_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEvent")) {
		Ifc_event *o = new Ifc_event();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->event_trigger_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->event_occurence_time = (Ifc_event_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->event_occurence_time);
if (boost::iequals(object_class, "IfcEventTime")) {
		Ifc_event_time *o = new Ifc_event_time();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->actual_date = step_parser.parse_string(object_attributes[%d]);
		o->early_date = step_parser.parse_string(object_attributes[%d]);
		o->late_date = step_parser.parse_string(object_attributes[%d]);
		o->schedule_date = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcEventType")) {
		Ifc_event_type *o = new Ifc_event_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->event_trigger_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcExtendedProperties")) {
		Ifc_extended_properties *o = new Ifc_extended_properties();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->properties.push_back((Ifc_property *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->properties);
if (boost::iequals(object_class, "IfcExternalInformation")) {
		Ifc_external_information *o = new Ifc_external_information();
if (boost::iequals(object_class, "IfcExternalReference")) {
		Ifc_external_reference *o = new Ifc_external_reference();
		o->location = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcExternalReferenceRelationship")) {
		Ifc_external_reference_relationship *o = new Ifc_external_reference_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_reference = (Ifc_external_reference *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_reference);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_resource_objects.push_back((Ifc_resource_object_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_resource_objects);
if (boost::iequals(object_class, "IfcExternalSpatialElement")) {
		Ifc_external_spatial_element *o = new Ifc_external_spatial_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcExternalSpatialStructureElement")) {
		Ifc_external_spatial_structure_element *o = new Ifc_external_spatial_structure_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcExternallyDefinedHatchStyle")) {
		Ifc_externally_defined_hatch_style *o = new Ifc_externally_defined_hatch_style();
		o->location = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcExternallyDefinedSurfaceStyle")) {
		Ifc_externally_defined_surface_style *o = new Ifc_externally_defined_surface_style();
		o->location = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcExternallyDefinedTextFont")) {
		Ifc_externally_defined_text_font *o = new Ifc_externally_defined_text_font();
		o->location = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcExtrudedAreaSolid")) {
		Ifc_extruded_area_solid *o = new Ifc_extruded_area_solid();
		o->swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_area);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->extruded_direction = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->extruded_direction);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcExtrudedAreaSolidTapered")) {
		Ifc_extruded_area_solid_tapered *o = new Ifc_extruded_area_solid_tapered();
		o->swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_area);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->extruded_direction = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->extruded_direction);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->end_swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->end_swept_area);
if (boost::iequals(object_class, "IfcFace")) {
		Ifc_face *o = new Ifc_face();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->bounds.push_back((Ifc_face_bound *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->bounds);
if (boost::iequals(object_class, "IfcFaceBasedSurfaceModel")) {
		Ifc_face_based_surface_model *o = new Ifc_face_based_surface_model();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->fbsm_faces.push_back((Ifc_connected_face_set *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->fbsm_faces);
if (boost::iequals(object_class, "IfcFaceBound")) {
		Ifc_face_bound *o = new Ifc_face_bound();
		o->bound = (Ifc_loop *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->bound);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFaceOuterBound")) {
		Ifc_face_outer_bound *o = new Ifc_face_outer_bound();
		o->bound = (Ifc_loop *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->bound);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFaceSurface")) {
		Ifc_face_surface *o = new Ifc_face_surface();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->bounds.push_back((Ifc_face_bound *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->bounds);
		o->face_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->face_surface);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFacetedBrep")) {
		Ifc_faceted_brep *o = new Ifc_faceted_brep();
		o->outer = (Ifc_closed_shell *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer);
if (boost::iequals(object_class, "IfcFacetedBrepWithVoids")) {
		Ifc_faceted_brep_with_voids *o = new Ifc_faceted_brep_with_voids();
		o->outer = (Ifc_closed_shell *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->voids.push_back((Ifc_closed_shell *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->voids);
if (boost::iequals(object_class, "IfcFailureConnectionCondition")) {
		Ifc_failure_connection_condition *o = new Ifc_failure_connection_condition();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->tension_failure_x = step_parser.parse_double(object_attributes[%d]);
		o->tension_failure_y = step_parser.parse_double(object_attributes[%d]);
		o->tension_failure_z = step_parser.parse_double(object_attributes[%d]);
		o->compression_failure_x = step_parser.parse_double(object_attributes[%d]);
		o->compression_failure_y = step_parser.parse_double(object_attributes[%d]);
		o->compression_failure_z = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFan")) {
		Ifc_fan *o = new Ifc_fan();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFanType")) {
		Ifc_fan_type *o = new Ifc_fan_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFastener")) {
		Ifc_fastener *o = new Ifc_fastener();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFastenerType")) {
		Ifc_fastener_type *o = new Ifc_fastener_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFeatureElement")) {
		Ifc_feature_element *o = new Ifc_feature_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFeatureElementAddition")) {
		Ifc_feature_element_addition *o = new Ifc_feature_element_addition();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFeatureElementSubtraction")) {
		Ifc_feature_element_subtraction *o = new Ifc_feature_element_subtraction();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFillAreaStyle")) {
		Ifc_fill_area_style *o = new Ifc_fill_area_style();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->fill_styles.push_back((Ifc_fill_style_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->fill_styles);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFillAreaStyleHatching")) {
		Ifc_fill_area_style_hatching *o = new Ifc_fill_area_style_hatching();
		o->hatch_line_appearance = (Ifc_curve_style *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->hatch_line_appearance);
		o->start_of_next_hatch_line = (Ifc_hatch_line_distance_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->start_of_next_hatch_line);
		o->point_of_reference_hatch_line = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->point_of_reference_hatch_line);
		o->pattern_start = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->pattern_start);
		o->hatch_line_angle = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFillAreaStyleTiles")) {
		Ifc_fill_area_style_tiles *o = new Ifc_fill_area_style_tiles();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->tiling_pattern.push_back((Ifc_vector *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->tiling_pattern);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->tiles.push_back((Ifc_styled_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->tiles);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
if (boost::iequals(object_class, "IfcFilter")) {
		Ifc_filter *o = new Ifc_filter();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFilterType")) {
		Ifc_filter_type *o = new Ifc_filter_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFireSuppressionTerminal")) {
		Ifc_fire_suppression_terminal *o = new Ifc_fire_suppression_terminal();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFireSuppressionTerminalType")) {
		Ifc_fire_suppression_terminal_type *o = new Ifc_fire_suppression_terminal_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFixedReferenceSweptAreaSolid")) {
		Ifc_fixed_reference_swept_area_solid *o = new Ifc_fixed_reference_swept_area_solid();
		o->swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_area);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->directrix = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->directrix);
		o->start_param = step_parser.parse_double(object_attributes[%d]);
		o->end_param = step_parser.parse_double(object_attributes[%d]);
		o->fixed_reference = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->fixed_reference);
if (boost::iequals(object_class, "IfcFlowController")) {
		Ifc_flow_controller *o = new Ifc_flow_controller();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFlowControllerType")) {
		Ifc_flow_controller_type *o = new Ifc_flow_controller_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcFlowFitting")) {
		Ifc_flow_fitting *o = new Ifc_flow_fitting();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFlowFittingType")) {
		Ifc_flow_fitting_type *o = new Ifc_flow_fitting_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcFlowInstrument")) {
		Ifc_flow_instrument *o = new Ifc_flow_instrument();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFlowInstrumentType")) {
		Ifc_flow_instrument_type *o = new Ifc_flow_instrument_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFlowMeter")) {
		Ifc_flow_meter *o = new Ifc_flow_meter();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFlowMeterType")) {
		Ifc_flow_meter_type *o = new Ifc_flow_meter_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFlowMovingDevice")) {
		Ifc_flow_moving_device *o = new Ifc_flow_moving_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFlowMovingDeviceType")) {
		Ifc_flow_moving_device_type *o = new Ifc_flow_moving_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcFlowSegment")) {
		Ifc_flow_segment *o = new Ifc_flow_segment();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFlowSegmentType")) {
		Ifc_flow_segment_type *o = new Ifc_flow_segment_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcFlowStorageDevice")) {
		Ifc_flow_storage_device *o = new Ifc_flow_storage_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFlowStorageDeviceType")) {
		Ifc_flow_storage_device_type *o = new Ifc_flow_storage_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcFlowTerminal")) {
		Ifc_flow_terminal *o = new Ifc_flow_terminal();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFlowTerminalType")) {
		Ifc_flow_terminal_type *o = new Ifc_flow_terminal_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcFlowTreatmentDevice")) {
		Ifc_flow_treatment_device *o = new Ifc_flow_treatment_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFlowTreatmentDeviceType")) {
		Ifc_flow_treatment_device_type *o = new Ifc_flow_treatment_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcFooting")) {
		Ifc_footing *o = new Ifc_footing();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFootingType")) {
		Ifc_footing_type *o = new Ifc_footing_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFurnishingElement")) {
		Ifc_furnishing_element *o = new Ifc_furnishing_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcFurnishingElementType")) {
		Ifc_furnishing_element_type *o = new Ifc_furnishing_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcFurniture")) {
		Ifc_furniture *o = new Ifc_furniture();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcFurnitureType")) {
		Ifc_furniture_type *o = new Ifc_furniture_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->assembly_place = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcGeographicElement")) {
		Ifc_geographic_element *o = new Ifc_geographic_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcGeographicElementType")) {
		Ifc_geographic_element_type *o = new Ifc_geographic_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcGeometricCurveSet")) {
		Ifc_geometric_curve_set *o = new Ifc_geometric_curve_set();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->elements.push_back((Ifc_geometric_set_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->elements);
if (boost::iequals(object_class, "IfcGeometricRepresentationContext")) {
		Ifc_geometric_representation_context *o = new Ifc_geometric_representation_context();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->coordinate_space_dimension = step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_double(object_attributes[%d]);
		o->world_coordinate_system = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->world_coordinate_system);
		o->true_north = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->true_north);
if (boost::iequals(object_class, "IfcGeometricRepresentationItem")) {
		Ifc_geometric_representation_item *o = new Ifc_geometric_representation_item();
if (boost::iequals(object_class, "IfcGeometricRepresentationSubContext")) {
		Ifc_geometric_representation_sub_context *o = new Ifc_geometric_representation_sub_context();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->coordinate_space_dimension = step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_double(object_attributes[%d]);
		o->world_coordinate_system = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->world_coordinate_system);
		o->true_north = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->true_north);
		o->parent_context = (Ifc_geometric_representation_context *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->parent_context);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
		o->target_view = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcGeometricSet")) {
		Ifc_geometric_set *o = new Ifc_geometric_set();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->elements.push_back((Ifc_geometric_set_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->elements);
if (boost::iequals(object_class, "IfcGrid")) {
		Ifc_grid *o = new Ifc_grid();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->u_axes.push_back((Ifc_grid_axis *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->u_axes);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->v_axes.push_back((Ifc_grid_axis *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->v_axes);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->w_axes.push_back((Ifc_grid_axis *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->w_axes);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcGridAxis")) {
		Ifc_grid_axis *o = new Ifc_grid_axis();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->axis_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_curve);
		o->same_sense = step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcGridPlacement")) {
		Ifc_grid_placement *o = new Ifc_grid_placement();
		o->placement_location = (Ifc_virtual_grid_intersection *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->placement_location);
		o->placement_ref_direction = (Ifc_grid_placement_direction_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->placement_ref_direction);
if (boost::iequals(object_class, "IfcGroup")) {
		Ifc_group *o = new Ifc_group();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcHalfSpaceSolid")) {
		Ifc_half_space_solid *o = new Ifc_half_space_solid();
		o->base_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_surface);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcHeatExchanger")) {
		Ifc_heat_exchanger *o = new Ifc_heat_exchanger();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcHeatExchangerType")) {
		Ifc_heat_exchanger_type *o = new Ifc_heat_exchanger_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcHumidifier")) {
		Ifc_humidifier *o = new Ifc_humidifier();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcHumidifierType")) {
		Ifc_humidifier_type *o = new Ifc_humidifier_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcIShapeProfileDef")) {
		Ifc_i_shape_profile_def *o = new Ifc_i_shape_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->flange_slope = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcImageTexture")) {
		Ifc_image_texture *o = new Ifc_image_texture();
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->texture_transform = (Ifc_cartesian_transformation_operator_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->texture_transform);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->parameter.push_back((Ifc_identifier *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->parameter);
		o->u_r_l_reference = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcIndexedColourMap")) {
		Ifc_indexed_colour_map *o = new Ifc_indexed_colour_map();
		o->mapped_to = (Ifc_tessellated_face_set *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->mapped_to);
		o->overrides = (Ifc_surface_style_shading *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->overrides);
		o->colours = (Ifc_colour_rgb_list *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->colours);
		o->colour_index = step_parser.parse_integer(object_attributes[%d]);
if (boost::iequals(object_class, "IfcIndexedTextureMap")) {
		Ifc_indexed_texture_map *o = new Ifc_indexed_texture_map();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->maps.push_back((Ifc_surface_texture *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->maps);
		o->mapped_to = (Ifc_tessellated_face_set *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->mapped_to);
		o->tex_coords = (Ifc_texture_vertex_list *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->tex_coords);
if (boost::iequals(object_class, "IfcIndexedTriangleTextureMap")) {
		Ifc_indexed_triangle_texture_map *o = new Ifc_indexed_triangle_texture_map();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->maps.push_back((Ifc_surface_texture *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->maps);
		o->mapped_to = (Ifc_tessellated_face_set *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->mapped_to);
		o->tex_coords = (Ifc_texture_vertex_list *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->tex_coords);
				//TODO: parse container of container
if (boost::iequals(object_class, "IfcInterceptor")) {
		Ifc_interceptor *o = new Ifc_interceptor();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcInterceptorType")) {
		Ifc_interceptor_type *o = new Ifc_interceptor_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcInventory")) {
		Ifc_inventory *o = new Ifc_inventory();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->jurisdiction = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->jurisdiction);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->responsible_persons.push_back((Ifc_person *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->responsible_persons);
		o->last_update_date = step_parser.parse_string(object_attributes[%d]);
		o->current_value = (Ifc_cost_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->current_value);
		o->original_value = (Ifc_cost_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->original_value);
if (boost::iequals(object_class, "IfcIrregularTimeSeries")) {
		Ifc_irregular_time_series *o = new Ifc_irregular_time_series();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->start_time = step_parser.parse_string(object_attributes[%d]);
		o->end_time = step_parser.parse_string(object_attributes[%d]);
		o->time_series_data_type = step_parser.parse_constant(object_attributes[%d]);
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->values.push_back((Ifc_irregular_time_series_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->values);
if (boost::iequals(object_class, "IfcIrregularTimeSeriesValue")) {
		Ifc_irregular_time_series_value *o = new Ifc_irregular_time_series_value();
		o->time_stamp = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->list_values.push_back((Ifc_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->list_values);
if (boost::iequals(object_class, "IfcJunctionBox")) {
		Ifc_junction_box *o = new Ifc_junction_box();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcJunctionBoxType")) {
		Ifc_junction_box_type *o = new Ifc_junction_box_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLShapeProfileDef")) {
		Ifc_l_shape_profile_def *o = new Ifc_l_shape_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->leg_slope = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLaborResource")) {
		Ifc_labor_resource *o = new Ifc_labor_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->usage = (Ifc_resource_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->usage);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLaborResourceType")) {
		Ifc_labor_resource_type *o = new Ifc_labor_resource_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLagTime")) {
		Ifc_lag_time *o = new Ifc_lag_time();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->lag_value = (Ifc_time_or_ratio_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->lag_value);
		o->duration_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLamp")) {
		Ifc_lamp *o = new Ifc_lamp();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLampType")) {
		Ifc_lamp_type *o = new Ifc_lamp_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLibraryInformation")) {
		Ifc_library_information *o = new Ifc_library_information();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->publisher = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->publisher);
		o->version_date = step_parser.parse_string(object_attributes[%d]);
		o->location = step_parser.parse_string(object_attributes[%d]);
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLibraryReference")) {
		Ifc_library_reference *o = new Ifc_library_reference();
		o->location = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_identifier Ifc_language_id;
		o->referenced_library = (Ifc_library_information *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->referenced_library);
if (boost::iequals(object_class, "IfcLightDistributionData")) {
		Ifc_light_distribution_data *o = new Ifc_light_distribution_data();
		o->main_plane_angle = step_parser.parse_double(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->secondary_plane_angle.push_back((Ifc_plane_angle_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->secondary_plane_angle);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->luminous_intensity.push_back((Ifc_luminous_intensity_distribution_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->luminous_intensity);
if (boost::iequals(object_class, "IfcLightFixture")) {
		Ifc_light_fixture *o = new Ifc_light_fixture();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLightFixtureType")) {
		Ifc_light_fixture_type *o = new Ifc_light_fixture_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLightIntensityDistribution")) {
		Ifc_light_intensity_distribution *o = new Ifc_light_intensity_distribution();
		o->light_distribution_curve = step_parser.parse_constant(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->distribution_data.push_back((Ifc_light_distribution_data *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->distribution_data);
if (boost::iequals(object_class, "IfcLightSource")) {
		Ifc_light_source *o = new Ifc_light_source();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->light_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->light_colour);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
if (boost::iequals(object_class, "IfcLightSourceAmbient")) {
		Ifc_light_source_ambient *o = new Ifc_light_source_ambient();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->light_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->light_colour);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
if (boost::iequals(object_class, "IfcLightSourceDirectional")) {
		Ifc_light_source_directional *o = new Ifc_light_source_directional();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->light_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->light_colour);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		o->orientation = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->orientation);
if (boost::iequals(object_class, "IfcLightSourceGoniometric")) {
		Ifc_light_source_goniometric *o = new Ifc_light_source_goniometric();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->light_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->light_colour);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->colour_appearance = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->colour_appearance);
		o->colour_temperature = step_parser.parse_double(object_attributes[%d]);
		o->luminous_flux = step_parser.parse_double(object_attributes[%d]);
		o->light_emission_source = step_parser.parse_constant(object_attributes[%d]);
		o->light_distribution_data_source = (Ifc_light_distribution_data_source_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->light_distribution_data_source);
if (boost::iequals(object_class, "IfcLightSourcePositional")) {
		Ifc_light_source_positional *o = new Ifc_light_source_positional();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->light_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->light_colour);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		o->position = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->constant_attenuation = step_parser.parse_double(object_attributes[%d]);
		o->distance_attenuation = step_parser.parse_double(object_attributes[%d]);
		o->quadric_attenuation = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcLightSourceSpot")) {
		Ifc_light_source_spot *o = new Ifc_light_source_spot();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->light_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->light_colour);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		o->position = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->constant_attenuation = step_parser.parse_double(object_attributes[%d]);
		o->distance_attenuation = step_parser.parse_double(object_attributes[%d]);
		o->quadric_attenuation = step_parser.parse_double(object_attributes[%d]);
		o->orientation = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->orientation);
		o->concentration_exponent = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_plane_angle_measure Ifc_positive_plane_angle_measure;
		//TODO: parse non-pointer type: typedef Ifc_plane_angle_measure Ifc_positive_plane_angle_measure;
if (boost::iequals(object_class, "IfcLine")) {
		Ifc_line *o = new Ifc_line();
		o->pnt = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->pnt);
		o->dir = (Ifc_vector *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->dir);
if (boost::iequals(object_class, "IfcLocalPlacement")) {
		Ifc_local_placement *o = new Ifc_local_placement();
		o->placement_rel_to = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->placement_rel_to);
		o->relative_placement = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relative_placement);
if (boost::iequals(object_class, "IfcLoop")) {
		Ifc_loop *o = new Ifc_loop();
if (boost::iequals(object_class, "IfcManifoldSolidBrep")) {
		Ifc_manifold_solid_brep *o = new Ifc_manifold_solid_brep();
		o->outer = (Ifc_closed_shell *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->outer);
if (boost::iequals(object_class, "IfcMapConversion")) {
		Ifc_map_conversion *o = new Ifc_map_conversion();
		o->source_c_r_s = (Ifc_coordinate_reference_system_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->source_c_r_s);
		o->target_c_r_s = (Ifc_coordinate_reference_system *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->target_c_r_s);
		o->eastings = step_parser.parse_double(object_attributes[%d]);
		o->northings = step_parser.parse_double(object_attributes[%d]);
		o->orthogonal_height = step_parser.parse_double(object_attributes[%d]);
		o->x_axis_abscissa = step_parser.parse_double(object_attributes[%d]);
		o->x_axis_ordinate = step_parser.parse_double(object_attributes[%d]);
		o->scale = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMappedItem")) {
		Ifc_mapped_item *o = new Ifc_mapped_item();
		o->mapping_source = (Ifc_representation_map *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->mapping_source);
		o->mapping_target = (Ifc_cartesian_transformation_operator *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->mapping_target);
if (boost::iequals(object_class, "IfcMaterial")) {
		Ifc_material *o = new Ifc_material();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcMaterialClassificationRelationship")) {
		Ifc_material_classification_relationship *o = new Ifc_material_classification_relationship();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->material_classifications.push_back((Ifc_classification_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->material_classifications);
		o->classified_material = (Ifc_material *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->classified_material);
if (boost::iequals(object_class, "IfcMaterialConstituent")) {
		Ifc_material_constituent *o = new Ifc_material_constituent();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->material = (Ifc_material *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->material);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcMaterialConstituentSet")) {
		Ifc_material_constituent_set *o = new Ifc_material_constituent_set();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->material_constituents.push_back((Ifc_material_constituent *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->material_constituents);
if (boost::iequals(object_class, "IfcMaterialDefinition")) {
		Ifc_material_definition *o = new Ifc_material_definition();
if (boost::iequals(object_class, "IfcMaterialDefinitionRepresentation")) {
		Ifc_material_definition_representation *o = new Ifc_material_definition_representation();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representations.push_back((Ifc_representation *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representations);
		o->represented_material = (Ifc_material *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->represented_material);
if (boost::iequals(object_class, "IfcMaterialLayer")) {
		Ifc_material_layer *o = new Ifc_material_layer();
		o->material = (Ifc_material *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->material);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->is_ventilated = step_parser.parse_integer(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
if (boost::iequals(object_class, "IfcMaterialLayerSet")) {
		Ifc_material_layer_set *o = new Ifc_material_layer_set();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->material_layers.push_back((Ifc_material_layer *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->material_layers);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMaterialLayerSetUsage")) {
		Ifc_material_layer_set_usage *o = new Ifc_material_layer_set_usage();
		o->for_layer_set = (Ifc_material_layer_set *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->for_layer_set);
		o->layer_set_direction = step_parser.parse_constant(object_attributes[%d]);
		o->direction_sense = step_parser.parse_constant(object_attributes[%d]);
		o->offset_from_reference_line = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcMaterialLayerWithOffsets")) {
		Ifc_material_layer_with_offsets *o = new Ifc_material_layer_with_offsets();
		o->material = (Ifc_material *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->material);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->is_ventilated = step_parser.parse_integer(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		o->offset_direction = step_parser.parse_constant(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->offset_values.push_back((Ifc_length_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->offset_values);
if (boost::iequals(object_class, "IfcMaterialList")) {
		Ifc_material_list *o = new Ifc_material_list();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->materials.push_back((Ifc_material *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->materials);
if (boost::iequals(object_class, "IfcMaterialProfile")) {
		Ifc_material_profile *o = new Ifc_material_profile();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->material = (Ifc_material *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->material);
		o->profile = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->profile);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcMaterialProfileSet")) {
		Ifc_material_profile_set *o = new Ifc_material_profile_set();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->material_profiles.push_back((Ifc_material_profile *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->material_profiles);
		o->composite_profile = (Ifc_composite_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->composite_profile);
if (boost::iequals(object_class, "IfcMaterialProfileSetUsage")) {
		Ifc_material_profile_set_usage *o = new Ifc_material_profile_set_usage();
		o->for_profile_set = (Ifc_material_profile_set *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->for_profile_set);
		o->cardinal_point = step_parser.parse_integer(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcMaterialProfileSetUsageTapering")) {
		Ifc_material_profile_set_usage_tapering *o = new Ifc_material_profile_set_usage_tapering();
		o->for_profile_set = (Ifc_material_profile_set *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->for_profile_set);
		o->cardinal_point = step_parser.parse_integer(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->for_profile_end_set = (Ifc_material_profile_set *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->for_profile_end_set);
		o->cardinal_end_point = step_parser.parse_integer(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMaterialProfileWithOffsets")) {
		Ifc_material_profile_with_offsets *o = new Ifc_material_profile_with_offsets();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->material = (Ifc_material *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->material);
		o->profile = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->profile);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->offset_values.push_back((Ifc_length_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->offset_values);
if (boost::iequals(object_class, "IfcMaterialProperties")) {
		Ifc_material_properties *o = new Ifc_material_properties();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->properties.push_back((Ifc_property *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->properties);
		o->material = (Ifc_material_definition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->material);
if (boost::iequals(object_class, "IfcMaterialRelationship")) {
		Ifc_material_relationship *o = new Ifc_material_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_material = (Ifc_material *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_material);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_materials.push_back((Ifc_material *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_materials);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcMaterialUsageDefinition")) {
		Ifc_material_usage_definition *o = new Ifc_material_usage_definition();
if (boost::iequals(object_class, "IfcMeasureWithUnit")) {
		Ifc_measure_with_unit *o = new Ifc_measure_with_unit();
		o->value_component = (Ifc_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->value_component);
		o->unit_component = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit_component);
if (boost::iequals(object_class, "IfcMechanicalFastener")) {
		Ifc_mechanical_fastener *o = new Ifc_mechanical_fastener();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMechanicalFastenerType")) {
		Ifc_mechanical_fastener_type *o = new Ifc_mechanical_fastener_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcMedicalDevice")) {
		Ifc_medical_device *o = new Ifc_medical_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMedicalDeviceType")) {
		Ifc_medical_device_type *o = new Ifc_medical_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMember")) {
		Ifc_member *o = new Ifc_member();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMemberStandardCase")) {
		Ifc_member_standard_case *o = new Ifc_member_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMemberType")) {
		Ifc_member_type *o = new Ifc_member_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMetric")) {
		Ifc_metric *o = new Ifc_metric();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->constraint_grade = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->creating_actor = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->creating_actor);
		o->creation_time = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->benchmark = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->data_value = (Ifc_metric_value_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->data_value);
		o->reference_path = (Ifc_reference *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->reference_path);
if (boost::iequals(object_class, "IfcMirroredProfileDef")) {
		Ifc_mirrored_profile_def *o = new Ifc_mirrored_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->parent_profile = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->parent_profile);
		o->operator = (Ifc_cartesian_transformation_operator_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->operator);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcMonetaryUnit")) {
		Ifc_monetary_unit *o = new Ifc_monetary_unit();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcMotorConnection")) {
		Ifc_motor_connection *o = new Ifc_motor_connection();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcMotorConnectionType")) {
		Ifc_motor_connection_type *o = new Ifc_motor_connection_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcNamedUnit")) {
		Ifc_named_unit *o = new Ifc_named_unit();
		o->dimensions = (Ifc_dimensional_exponents *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->dimensions);
		o->unit_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcObject")) {
		Ifc_object *o = new Ifc_object();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcObjectDefinition")) {
		Ifc_object_definition *o = new Ifc_object_definition();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcObjectPlacement")) {
		Ifc_object_placement *o = new Ifc_object_placement();
if (boost::iequals(object_class, "IfcObjective")) {
		Ifc_objective *o = new Ifc_objective();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->constraint_grade = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->creating_actor = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->creating_actor);
		o->creation_time = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->benchmark_values.push_back((Ifc_constraint *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->benchmark_values);
		o->logical_aggregator = step_parser.parse_constant(object_attributes[%d]);
		o->objective_qualifier = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcOccupant")) {
		Ifc_occupant *o = new Ifc_occupant();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->the_actor = (Ifc_actor_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->the_actor);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcOffsetCurve2D")) {
		Ifc_offset_curve_2_d *o = new Ifc_offset_curve_2_d();
		o->basis_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_curve);
		o->distance = step_parser.parse_double(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
if (boost::iequals(object_class, "IfcOffsetCurve3D")) {
		Ifc_offset_curve_3_d *o = new Ifc_offset_curve_3_d();
		o->basis_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_curve);
		o->distance = step_parser.parse_double(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		o->ref_direction = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->ref_direction);
if (boost::iequals(object_class, "IfcOpenShell")) {
		Ifc_open_shell *o = new Ifc_open_shell();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->cfs_faces.push_back((Ifc_face *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->cfs_faces);
if (boost::iequals(object_class, "IfcOpeningElement")) {
		Ifc_opening_element *o = new Ifc_opening_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcOpeningStandardCase")) {
		Ifc_opening_standard_case *o = new Ifc_opening_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcOrganization")) {
		Ifc_organization *o = new Ifc_organization();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->roles.push_back((Ifc_actor_role *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->roles);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->addresses.push_back((Ifc_address *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->addresses);
if (boost::iequals(object_class, "IfcOrganizationRelationship")) {
		Ifc_organization_relationship *o = new Ifc_organization_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_organization = (Ifc_organization *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_organization);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_organizations.push_back((Ifc_organization *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_organizations);
if (boost::iequals(object_class, "IfcOrientedEdge")) {
		Ifc_oriented_edge *o = new Ifc_oriented_edge();
		o->edge_start = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_start);
		o->edge_end = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_end);
		o->edge_element = (Ifc_edge *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_element);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcOuterBoundaryCurve")) {
		Ifc_outer_boundary_curve *o = new Ifc_outer_boundary_curve();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->segments.push_back((Ifc_composite_curve_segment *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->segments);
		//o->step_parser.parse_logical(object_attributes[%d]);
if (boost::iequals(object_class, "IfcOutlet")) {
		Ifc_outlet *o = new Ifc_outlet();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcOutletType")) {
		Ifc_outlet_type *o = new Ifc_outlet_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcOwnerHistory")) {
		Ifc_owner_history *o = new Ifc_owner_history();
		o->owning_user = (Ifc_person_and_organization *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owning_user);
		o->owning_application = (Ifc_application *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owning_application);
		o->state = step_parser.parse_constant(object_attributes[%d]);
		o->change_action = step_parser.parse_constant(object_attributes[%d]);
		o->last_modified_date = step_parser.parse_integer(object_attributes[%d]);
		o->last_modifying_user = (Ifc_person_and_organization *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->last_modifying_user);
		o->last_modifying_application = (Ifc_application *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->last_modifying_application);
		o->creation_date = step_parser.parse_integer(object_attributes[%d]);
if (boost::iequals(object_class, "IfcParameterizedProfileDef")) {
		Ifc_parameterized_profile_def *o = new Ifc_parameterized_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
if (boost::iequals(object_class, "IfcPath")) {
		Ifc_path *o = new Ifc_path();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->edge_list.push_back((Ifc_oriented_edge *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->edge_list);
if (boost::iequals(object_class, "IfcPcurve")) {
		Ifc_pcurve *o = new Ifc_pcurve();
		o->basis_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_surface);
		o->reference_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->reference_curve);
if (boost::iequals(object_class, "IfcPerformanceHistory")) {
		Ifc_performance_history *o = new Ifc_performance_history();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPermeableCoveringProperties")) {
		Ifc_permeable_covering_properties *o = new Ifc_permeable_covering_properties();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->operation_type = step_parser.parse_constant(object_attributes[%d]);
		o->panel_position = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->shape_aspect_style = (Ifc_shape_aspect *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->shape_aspect_style);
if (boost::iequals(object_class, "IfcPermit")) {
		Ifc_permit *o = new Ifc_permit();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPerson")) {
		Ifc_person *o = new Ifc_person();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->middle_names.push_back((Ifc_label *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->middle_names);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->prefix_titles.push_back((Ifc_label *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->prefix_titles);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->suffix_titles.push_back((Ifc_label *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->suffix_titles);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->roles.push_back((Ifc_actor_role *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->roles);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->addresses.push_back((Ifc_address *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->addresses);
if (boost::iequals(object_class, "IfcPersonAndOrganization")) {
		Ifc_person_and_organization *o = new Ifc_person_and_organization();
		o->the_person = (Ifc_person *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->the_person);
		o->the_organization = (Ifc_organization *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->the_organization);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->roles.push_back((Ifc_actor_role *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->roles);
if (boost::iequals(object_class, "IfcPhysicalComplexQuantity")) {
		Ifc_physical_complex_quantity *o = new Ifc_physical_complex_quantity();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_quantities.push_back((Ifc_physical_quantity *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_quantities);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcPhysicalQuantity")) {
		Ifc_physical_quantity *o = new Ifc_physical_quantity();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPhysicalSimpleQuantity")) {
		Ifc_physical_simple_quantity *o = new Ifc_physical_simple_quantity();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
if (boost::iequals(object_class, "IfcPile")) {
		Ifc_pile *o = new Ifc_pile();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->construction_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPileType")) {
		Ifc_pile_type *o = new Ifc_pile_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPipeFitting")) {
		Ifc_pipe_fitting *o = new Ifc_pipe_fitting();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPipeFittingType")) {
		Ifc_pipe_fitting_type *o = new Ifc_pipe_fitting_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPipeSegment")) {
		Ifc_pipe_segment *o = new Ifc_pipe_segment();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPipeSegmentType")) {
		Ifc_pipe_segment_type *o = new Ifc_pipe_segment_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPixelTexture")) {
		Ifc_pixel_texture *o = new Ifc_pixel_texture();
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->texture_transform = (Ifc_cartesian_transformation_operator_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->texture_transform);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->parameter.push_back((Ifc_identifier *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->parameter);
		o->width = step_parser.parse_integer(object_attributes[%d]);
		o->height = step_parser.parse_integer(object_attributes[%d]);
		o->colour_components = step_parser.parse_integer(object_attributes[%d]);
		//TODO: parse other container of pod
if (boost::iequals(object_class, "IfcPlacement")) {
		Ifc_placement *o = new Ifc_placement();
		o->location = (Ifc_cartesian_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->location);
if (boost::iequals(object_class, "IfcPlanarBox")) {
		Ifc_planar_box *o = new Ifc_planar_box();
		o->size_in_x = step_parser.parse_double(object_attributes[%d]);
		o->size_in_y = step_parser.parse_double(object_attributes[%d]);
		o->placement = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->placement);
if (boost::iequals(object_class, "IfcPlanarExtent")) {
		Ifc_planar_extent *o = new Ifc_planar_extent();
		o->size_in_x = step_parser.parse_double(object_attributes[%d]);
		o->size_in_y = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPlane")) {
		Ifc_plane *o = new Ifc_plane();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
if (boost::iequals(object_class, "IfcPlate")) {
		Ifc_plate *o = new Ifc_plate();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPlateStandardCase")) {
		Ifc_plate_standard_case *o = new Ifc_plate_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPlateType")) {
		Ifc_plate_type *o = new Ifc_plate_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPoint")) {
		Ifc_point *o = new Ifc_point();
if (boost::iequals(object_class, "IfcPointOnCurve")) {
		Ifc_point_on_curve *o = new Ifc_point_on_curve();
		o->basis_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_curve);
		o->point_parameter = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPointOnSurface")) {
		Ifc_point_on_surface *o = new Ifc_point_on_surface();
		o->basis_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_surface);
		o->point_parameter_u = step_parser.parse_double(object_attributes[%d]);
		o->point_parameter_v = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPolyLoop")) {
		Ifc_poly_loop *o = new Ifc_poly_loop();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->polygon.push_back((Ifc_cartesian_point *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->polygon);
if (boost::iequals(object_class, "IfcPolygonalBoundedHalfSpace")) {
		Ifc_polygonal_bounded_half_space *o = new Ifc_polygonal_bounded_half_space();
		o->base_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_surface);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->polygonal_boundary = (Ifc_bounded_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->polygonal_boundary);
if (boost::iequals(object_class, "IfcPolyline")) {
		Ifc_polyline *o = new Ifc_polyline();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->points.push_back((Ifc_cartesian_point *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->points);
if (boost::iequals(object_class, "IfcPort")) {
		Ifc_port *o = new Ifc_port();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
if (boost::iequals(object_class, "IfcPostalAddress")) {
		Ifc_postal_address *o = new Ifc_postal_address();
		o->purpose = step_parser.parse_constant(object_attributes[%d]);
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->address_lines.push_back((Ifc_label *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->address_lines);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcPreDefinedColour")) {
		Ifc_pre_defined_colour *o = new Ifc_pre_defined_colour();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcPreDefinedCurveFont")) {
		Ifc_pre_defined_curve_font *o = new Ifc_pre_defined_curve_font();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcPreDefinedItem")) {
		Ifc_pre_defined_item *o = new Ifc_pre_defined_item();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcPreDefinedProperties")) {
		Ifc_pre_defined_properties *o = new Ifc_pre_defined_properties();
if (boost::iequals(object_class, "IfcPreDefinedPropertySet")) {
		Ifc_pre_defined_property_set *o = new Ifc_pre_defined_property_set();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPreDefinedTextFont")) {
		Ifc_pre_defined_text_font *o = new Ifc_pre_defined_text_font();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcPresentationItem")) {
		Ifc_presentation_item *o = new Ifc_presentation_item();
if (boost::iequals(object_class, "IfcPresentationLayerAssignment")) {
		Ifc_presentation_layer_assignment *o = new Ifc_presentation_layer_assignment();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->assigned_items.push_back((Ifc_layered_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->assigned_items);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcPresentationLayerWithStyle")) {
		Ifc_presentation_layer_with_style *o = new Ifc_presentation_layer_with_style();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->assigned_items.push_back((Ifc_layered_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->assigned_items);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->layer_styles.push_back((Ifc_presentation_style *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->layer_styles);
if (boost::iequals(object_class, "IfcPresentationStyle")) {
		Ifc_presentation_style *o = new Ifc_presentation_style();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcPresentationStyleAssignment")) {
		Ifc_presentation_style_assignment *o = new Ifc_presentation_style_assignment();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->styles.push_back((Ifc_presentation_style_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->styles);
if (boost::iequals(object_class, "IfcProcedure")) {
		Ifc_procedure *o = new Ifc_procedure();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProcedureType")) {
		Ifc_procedure_type *o = new Ifc_procedure_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProcess")) {
		Ifc_process *o = new Ifc_process();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProduct")) {
		Ifc_product *o = new Ifc_product();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
if (boost::iequals(object_class, "IfcProductDefinitionShape")) {
		Ifc_product_definition_shape *o = new Ifc_product_definition_shape();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representations.push_back((Ifc_representation *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representations);
if (boost::iequals(object_class, "IfcProductRepresentation")) {
		Ifc_product_representation *o = new Ifc_product_representation();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representations.push_back((Ifc_representation *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representations);
if (boost::iequals(object_class, "IfcProfileDef")) {
		Ifc_profile_def *o = new Ifc_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcProfileProperties")) {
		Ifc_profile_properties *o = new Ifc_profile_properties();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->properties.push_back((Ifc_property *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->properties);
		o->profile_definition = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->profile_definition);
if (boost::iequals(object_class, "IfcProject")) {
		Ifc_project *o = new Ifc_project();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_contexts.push_back((Ifc_representation_context *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_contexts);
		o->units_in_context = (Ifc_unit_assignment *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->units_in_context);
if (boost::iequals(object_class, "IfcProjectLibrary")) {
		Ifc_project_library *o = new Ifc_project_library();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_contexts.push_back((Ifc_representation_context *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_contexts);
		o->units_in_context = (Ifc_unit_assignment *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->units_in_context);
if (boost::iequals(object_class, "IfcProjectOrder")) {
		Ifc_project_order *o = new Ifc_project_order();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProjectedCRS")) {
		Ifc_projected_c_r_s *o = new Ifc_projected_c_r_s();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->map_unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->map_unit);
if (boost::iequals(object_class, "IfcProjectionElement")) {
		Ifc_projection_element *o = new Ifc_projection_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProperty")) {
		Ifc_property *o = new Ifc_property();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPropertyAbstraction")) {
		Ifc_property_abstraction *o = new Ifc_property_abstraction();
if (boost::iequals(object_class, "IfcPropertyBoundedValue")) {
		Ifc_property_bounded_value *o = new Ifc_property_bounded_value();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->upper_bound_value = (Ifc_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->upper_bound_value);
		o->lower_bound_value = (Ifc_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->lower_bound_value);
		o->unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->set_point_value = (Ifc_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->set_point_value);
if (boost::iequals(object_class, "IfcPropertyDefinition")) {
		Ifc_property_definition *o = new Ifc_property_definition();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPropertyDependencyRelationship")) {
		Ifc_property_dependency_relationship *o = new Ifc_property_dependency_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->depending_property = (Ifc_property *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->depending_property);
		o->dependant_property = (Ifc_property *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->dependant_property);
		o->expression = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPropertyEnumeratedValue")) {
		Ifc_property_enumerated_value *o = new Ifc_property_enumerated_value();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->enumeration_values.push_back((Ifc_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->enumeration_values);
		o->enumeration_reference = (Ifc_property_enumeration *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->enumeration_reference);
if (boost::iequals(object_class, "IfcPropertyEnumeration")) {
		Ifc_property_enumeration *o = new Ifc_property_enumeration();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->enumeration_values.push_back((Ifc_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->enumeration_values);
		o->unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
if (boost::iequals(object_class, "IfcPropertyListValue")) {
		Ifc_property_list_value *o = new Ifc_property_list_value();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->list_values.push_back((Ifc_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->list_values);
		o->unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
if (boost::iequals(object_class, "IfcPropertyReferenceValue")) {
		Ifc_property_reference_value *o = new Ifc_property_reference_value();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->usage_name = step_parser.parse_string(object_attributes[%d]);
		o->property_reference = (Ifc_object_reference_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->property_reference);
if (boost::iequals(object_class, "IfcPropertySet")) {
		Ifc_property_set *o = new Ifc_property_set();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_properties.push_back((Ifc_property *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_properties);
if (boost::iequals(object_class, "IfcPropertySetDefinition")) {
		Ifc_property_set_definition *o = new Ifc_property_set_definition();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPropertySetTemplate")) {
		Ifc_property_set_template *o = new Ifc_property_set_template();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->template_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_templates.push_back((Ifc_property_template *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_templates);
if (boost::iequals(object_class, "IfcPropertySingleValue")) {
		Ifc_property_single_value *o = new Ifc_property_single_value();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->nominal_value = (Ifc_value *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->nominal_value);
		o->unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
if (boost::iequals(object_class, "IfcPropertyTableValue")) {
		Ifc_property_table_value *o = new Ifc_property_table_value();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->defining_values.push_back((Ifc_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->defining_values);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->defined_values.push_back((Ifc_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->defined_values);
		o->expression = step_parser.parse_string(object_attributes[%d]);
		o->defining_unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->defining_unit);
		o->defined_unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->defined_unit);
		o->curve_interpolation = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPropertyTemplate")) {
		Ifc_property_template *o = new Ifc_property_template();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPropertyTemplateDefinition")) {
		Ifc_property_template_definition *o = new Ifc_property_template_definition();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProtectiveDevice")) {
		Ifc_protective_device *o = new Ifc_protective_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProtectiveDeviceTrippingUnit")) {
		Ifc_protective_device_tripping_unit *o = new Ifc_protective_device_tripping_unit();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProtectiveDeviceTrippingUnitType")) {
		Ifc_protective_device_tripping_unit_type *o = new Ifc_protective_device_tripping_unit_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProtectiveDeviceType")) {
		Ifc_protective_device_type *o = new Ifc_protective_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcProxy")) {
		Ifc_proxy *o = new Ifc_proxy();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->proxy_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcPump")) {
		Ifc_pump *o = new Ifc_pump();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcPumpType")) {
		Ifc_pump_type *o = new Ifc_pump_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcQuantityArea")) {
		Ifc_quantity_area *o = new Ifc_quantity_area();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->area_value = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcQuantityCount")) {
		Ifc_quantity_count *o = new Ifc_quantity_count();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		//TODO: parse non-pointer type: typedef unsigned int Ifc_count_measure;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcQuantityLength")) {
		Ifc_quantity_length *o = new Ifc_quantity_length();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->length_value = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcQuantitySet")) {
		Ifc_quantity_set *o = new Ifc_quantity_set();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcQuantityTime")) {
		Ifc_quantity_time *o = new Ifc_quantity_time();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->time_value = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcQuantityVolume")) {
		Ifc_quantity_volume *o = new Ifc_quantity_volume();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->volume_value = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcQuantityWeight")) {
		Ifc_quantity_weight *o = new Ifc_quantity_weight();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->unit = (Ifc_named_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->weight_value = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcRailing")) {
		Ifc_railing *o = new Ifc_railing();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRailingType")) {
		Ifc_railing_type *o = new Ifc_railing_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRamp")) {
		Ifc_ramp *o = new Ifc_ramp();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRampFlight")) {
		Ifc_ramp_flight *o = new Ifc_ramp_flight();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRampFlightType")) {
		Ifc_ramp_flight_type *o = new Ifc_ramp_flight_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRampType")) {
		Ifc_ramp_type *o = new Ifc_ramp_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRationalBSplineCurveWithKnots")) {
		Ifc_rational_b_spline_curve_with_knots *o = new Ifc_rational_b_spline_curve_with_knots();
		o->step_parser.parse_integer(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->control_points_list.push_back((Ifc_cartesian_point *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->control_points_list);
		o->curve_form = step_parser.parse_constant(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		o->knot_multiplicities = step_parser.parse_integer(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->knots.push_back((Ifc_parameter_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->knots);
		o->knot_spec = step_parser.parse_constant(object_attributes[%d]);
		o->weights_data = step_parser.parse_list_of_doubles(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRationalBSplineSurfaceWithKnots")) {
		Ifc_rational_b_spline_surface_with_knots *o = new Ifc_rational_b_spline_surface_with_knots();
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
				//TODO: parse container of container
		o->surface_form = step_parser.parse_constant(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		o->u_multiplicities = step_parser.parse_integer(object_attributes[%d]);
		o->v_multiplicities = step_parser.parse_integer(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->u_knots.push_back((Ifc_parameter_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->u_knots);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->v_knots.push_back((Ifc_parameter_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->v_knots);
		o->knot_spec = step_parser.parse_constant(object_attributes[%d]);
				//TODO: parse container of container
if (boost::iequals(object_class, "IfcRectangleHollowProfileDef")) {
		Ifc_rectangle_hollow_profile_def *o = new Ifc_rectangle_hollow_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
if (boost::iequals(object_class, "IfcRectangleProfileDef")) {
		Ifc_rectangle_profile_def *o = new Ifc_rectangle_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcRectangularPyramid")) {
		Ifc_rectangular_pyramid *o = new Ifc_rectangular_pyramid();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcRectangularTrimmedSurface")) {
		Ifc_rectangular_trimmed_surface *o = new Ifc_rectangular_trimmed_surface();
		o->basis_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_surface);
		o->u_1 = step_parser.parse_double(object_attributes[%d]);
		o->v_1 = step_parser.parse_double(object_attributes[%d]);
		o->u_2 = step_parser.parse_double(object_attributes[%d]);
		o->v_2 = step_parser.parse_double(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRecurrencePattern")) {
		Ifc_recurrence_pattern *o = new Ifc_recurrence_pattern();
		o->recurrence_type = step_parser.parse_constant(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->day_component.push_back((Ifc_day_in_month_number *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->day_component);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->weekday_component.push_back((Ifc_day_in_week_number *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->weekday_component);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->month_component.push_back((Ifc_month_in_year_number *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->month_component);
		o->position = step_parser.parse_integer(object_attributes[%d]);
		o->interval = step_parser.parse_integer(object_attributes[%d]);
		o->occurrences = step_parser.parse_integer(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->time_periods.push_back((Ifc_time_period *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->time_periods);
if (boost::iequals(object_class, "IfcReference")) {
		Ifc_reference *o = new Ifc_reference();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->list_positions = step_parser.parse_integer(object_attributes[%d]);
		o->inner_reference = (Ifc_reference *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->inner_reference);
if (boost::iequals(object_class, "IfcRegularTimeSeries")) {
		Ifc_regular_time_series *o = new Ifc_regular_time_series();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->start_time = step_parser.parse_string(object_attributes[%d]);
		o->end_time = step_parser.parse_string(object_attributes[%d]);
		o->time_series_data_type = step_parser.parse_constant(object_attributes[%d]);
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->time_step = step_parser.parse_double(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->values.push_back((Ifc_time_series_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->values);
if (boost::iequals(object_class, "IfcReinforcementBarProperties")) {
		Ifc_reinforcement_bar_properties *o = new Ifc_reinforcement_bar_properties();
		o->total_cross_section_area = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->bar_surface = step_parser.parse_constant(object_attributes[%d]);
		o->effective_depth = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef unsigned int Ifc_count_measure;
if (boost::iequals(object_class, "IfcReinforcementDefinitionProperties")) {
		Ifc_reinforcement_definition_properties *o = new Ifc_reinforcement_definition_properties();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->reinforcement_section_definitions.push_back((Ifc_section_reinforcement_properties *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->reinforcement_section_definitions);
if (boost::iequals(object_class, "IfcReinforcingBar")) {
		Ifc_reinforcing_bar *o = new Ifc_reinforcing_bar();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->cross_section_area = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->bar_surface = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcReinforcingBarType")) {
		Ifc_reinforcing_bar_type *o = new Ifc_reinforcing_bar_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->cross_section_area = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->bar_surface = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->bending_parameters.push_back((Ifc_bending_parameter_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->bending_parameters);
if (boost::iequals(object_class, "IfcReinforcingElement")) {
		Ifc_reinforcing_element *o = new Ifc_reinforcing_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcReinforcingElementType")) {
		Ifc_reinforcing_element_type *o = new Ifc_reinforcing_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcReinforcingMesh")) {
		Ifc_reinforcing_mesh *o = new Ifc_reinforcing_mesh();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->longitudinal_bar_cross_section_area = step_parser.parse_double(object_attributes[%d]);
		o->transverse_bar_cross_section_area = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcReinforcingMeshType")) {
		Ifc_reinforcing_mesh_type *o = new Ifc_reinforcing_mesh_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->longitudinal_bar_cross_section_area = step_parser.parse_double(object_attributes[%d]);
		o->transverse_bar_cross_section_area = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->bending_parameters.push_back((Ifc_bending_parameter_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->bending_parameters);
if (boost::iequals(object_class, "IfcRelAggregates")) {
		Ifc_rel_aggregates *o = new Ifc_rel_aggregates();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_object = (Ifc_object_definition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_object);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
if (boost::iequals(object_class, "IfcRelAssigns")) {
		Ifc_rel_assigns *o = new Ifc_rel_assigns();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->related_objects_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRelAssignsToActor")) {
		Ifc_rel_assigns_to_actor *o = new Ifc_rel_assigns_to_actor();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->related_objects_type = step_parser.parse_constant(object_attributes[%d]);
		o->relating_actor = (Ifc_actor *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_actor);
		o->acting_role = (Ifc_actor_role *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->acting_role);
if (boost::iequals(object_class, "IfcRelAssignsToControl")) {
		Ifc_rel_assigns_to_control *o = new Ifc_rel_assigns_to_control();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->related_objects_type = step_parser.parse_constant(object_attributes[%d]);
		o->relating_control = (Ifc_control *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_control);
if (boost::iequals(object_class, "IfcRelAssignsToGroup")) {
		Ifc_rel_assigns_to_group *o = new Ifc_rel_assigns_to_group();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->related_objects_type = step_parser.parse_constant(object_attributes[%d]);
		o->relating_group = (Ifc_group *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_group);
if (boost::iequals(object_class, "IfcRelAssignsToGroupByFactor")) {
		Ifc_rel_assigns_to_group_by_factor *o = new Ifc_rel_assigns_to_group_by_factor();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->related_objects_type = step_parser.parse_constant(object_attributes[%d]);
		o->relating_group = (Ifc_group *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_group);
		o->factor = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRelAssignsToProcess")) {
		Ifc_rel_assigns_to_process *o = new Ifc_rel_assigns_to_process();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->related_objects_type = step_parser.parse_constant(object_attributes[%d]);
		o->relating_process = (Ifc_process_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_process);
		o->quantity_in_process = (Ifc_measure_with_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->quantity_in_process);
if (boost::iequals(object_class, "IfcRelAssignsToProduct")) {
		Ifc_rel_assigns_to_product *o = new Ifc_rel_assigns_to_product();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->related_objects_type = step_parser.parse_constant(object_attributes[%d]);
		o->relating_product = (Ifc_product_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_product);
if (boost::iequals(object_class, "IfcRelAssignsToResource")) {
		Ifc_rel_assigns_to_resource *o = new Ifc_rel_assigns_to_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->related_objects_type = step_parser.parse_constant(object_attributes[%d]);
		o->relating_resource = (Ifc_resource_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_resource);
if (boost::iequals(object_class, "IfcRelAssociates")) {
		Ifc_rel_associates *o = new Ifc_rel_associates();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_definition_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
if (boost::iequals(object_class, "IfcRelAssociatesApproval")) {
		Ifc_rel_associates_approval *o = new Ifc_rel_associates_approval();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_definition_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->relating_approval = (Ifc_approval *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_approval);
if (boost::iequals(object_class, "IfcRelAssociatesClassification")) {
		Ifc_rel_associates_classification *o = new Ifc_rel_associates_classification();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_definition_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->relating_classification = (Ifc_classification_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_classification);
if (boost::iequals(object_class, "IfcRelAssociatesConstraint")) {
		Ifc_rel_associates_constraint *o = new Ifc_rel_associates_constraint();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_definition_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->relating_constraint = (Ifc_constraint *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_constraint);
if (boost::iequals(object_class, "IfcRelAssociatesDocument")) {
		Ifc_rel_associates_document *o = new Ifc_rel_associates_document();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_definition_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->relating_document = (Ifc_document_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_document);
if (boost::iequals(object_class, "IfcRelAssociatesLibrary")) {
		Ifc_rel_associates_library *o = new Ifc_rel_associates_library();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_definition_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->relating_library = (Ifc_library_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_library);
if (boost::iequals(object_class, "IfcRelAssociatesMaterial")) {
		Ifc_rel_associates_material *o = new Ifc_rel_associates_material();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_definition_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->relating_material = (Ifc_material_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_material);
if (boost::iequals(object_class, "IfcRelConnects")) {
		Ifc_rel_connects *o = new Ifc_rel_connects();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRelConnectsElements")) {
		Ifc_rel_connects_elements *o = new Ifc_rel_connects_elements();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->connection_geometry = (Ifc_connection_geometry *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->connection_geometry);
		o->relating_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_element);
		o->related_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_element);
if (boost::iequals(object_class, "IfcRelConnectsPathElements")) {
		Ifc_rel_connects_path_elements *o = new Ifc_rel_connects_path_elements();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->connection_geometry = (Ifc_connection_geometry *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->connection_geometry);
		o->relating_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_element);
		o->related_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_element);
		//o->relating_priorities = step_parser.parse_unsigned_integer(object_attributes[%d]);
		//o->related_priorities = step_parser.parse_unsigned_integer(object_attributes[%d]);
		o->related_connection_type = step_parser.parse_constant(object_attributes[%d]);
		o->relating_connection_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRelConnectsPortToElement")) {
		Ifc_rel_connects_port_to_element *o = new Ifc_rel_connects_port_to_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_port = (Ifc_port *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_port);
		o->related_element = (Ifc_distribution_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_element);
if (boost::iequals(object_class, "IfcRelConnectsPorts")) {
		Ifc_rel_connects_ports *o = new Ifc_rel_connects_ports();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_port = (Ifc_port *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_port);
		o->related_port = (Ifc_port *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_port);
		o->realizing_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->realizing_element);
if (boost::iequals(object_class, "IfcRelConnectsStructuralActivity")) {
		Ifc_rel_connects_structural_activity *o = new Ifc_rel_connects_structural_activity();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_element = (Ifc_structural_activity_assignment_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_element);
		o->related_structural_activity = (Ifc_structural_activity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_structural_activity);
if (boost::iequals(object_class, "IfcRelConnectsStructuralMember")) {
		Ifc_rel_connects_structural_member *o = new Ifc_rel_connects_structural_member();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_structural_member = (Ifc_structural_member *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_structural_member);
		o->related_structural_connection = (Ifc_structural_connection *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_structural_connection);
		o->applied_condition = (Ifc_boundary_condition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_condition);
		o->additional_conditions = (Ifc_structural_connection_condition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->additional_conditions);
		o->supported_length = step_parser.parse_double(object_attributes[%d]);
		o->condition_coordinate_system = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->condition_coordinate_system);
if (boost::iequals(object_class, "IfcRelConnectsWithEccentricity")) {
		Ifc_rel_connects_with_eccentricity *o = new Ifc_rel_connects_with_eccentricity();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_structural_member = (Ifc_structural_member *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_structural_member);
		o->related_structural_connection = (Ifc_structural_connection *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_structural_connection);
		o->applied_condition = (Ifc_boundary_condition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_condition);
		o->additional_conditions = (Ifc_structural_connection_condition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->additional_conditions);
		o->supported_length = step_parser.parse_double(object_attributes[%d]);
		o->condition_coordinate_system = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->condition_coordinate_system);
		o->connection_constraint = (Ifc_connection_geometry *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->connection_constraint);
if (boost::iequals(object_class, "IfcRelConnectsWithRealizingElements")) {
		Ifc_rel_connects_with_realizing_elements *o = new Ifc_rel_connects_with_realizing_elements();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->connection_geometry = (Ifc_connection_geometry *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->connection_geometry);
		o->relating_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_element);
		o->related_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_element);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->realizing_elements.push_back((Ifc_element *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->realizing_elements);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcRelContainedInSpatialStructure")) {
		Ifc_rel_contained_in_spatial_structure *o = new Ifc_rel_contained_in_spatial_structure();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_elements.push_back((Ifc_product *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_elements);
		o->relating_structure = (Ifc_spatial_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_structure);
if (boost::iequals(object_class, "IfcRelCoversBldgElements")) {
		Ifc_rel_covers_bldg_elements *o = new Ifc_rel_covers_bldg_elements();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_building_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_building_element);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_coverings.push_back((Ifc_covering *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_coverings);
if (boost::iequals(object_class, "IfcRelCoversSpaces")) {
		Ifc_rel_covers_spaces *o = new Ifc_rel_covers_spaces();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_space = (Ifc_space *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_space);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_coverings.push_back((Ifc_covering *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_coverings);
if (boost::iequals(object_class, "IfcRelDeclares")) {
		Ifc_rel_declares *o = new Ifc_rel_declares();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_context = (Ifc_context *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_context);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_definitions.push_back((Ifc_definition_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_definitions);
if (boost::iequals(object_class, "IfcRelDecomposes")) {
		Ifc_rel_decomposes *o = new Ifc_rel_decomposes();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRelDefines")) {
		Ifc_rel_defines *o = new Ifc_rel_defines();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRelDefinesByObject")) {
		Ifc_rel_defines_by_object *o = new Ifc_rel_defines_by_object();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->relating_object = (Ifc_object *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_object);
if (boost::iequals(object_class, "IfcRelDefinesByProperties")) {
		Ifc_rel_defines_by_properties *o = new Ifc_rel_defines_by_properties();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->relating_property_definition = (Ifc_property_set_definition_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_property_definition);
if (boost::iequals(object_class, "IfcRelDefinesByTemplate")) {
		Ifc_rel_defines_by_template *o = new Ifc_rel_defines_by_template();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_property_sets);
		o->relating_template = (Ifc_property_set_template *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_template);
if (boost::iequals(object_class, "IfcRelDefinesByType")) {
		Ifc_rel_defines_by_type *o = new Ifc_rel_defines_by_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
		o->relating_type = (Ifc_type_object *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_type);
if (boost::iequals(object_class, "IfcRelFillsElement")) {
		Ifc_rel_fills_element *o = new Ifc_rel_fills_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_opening_element = (Ifc_opening_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_opening_element);
		o->related_building_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_building_element);
if (boost::iequals(object_class, "IfcRelFlowControlElements")) {
		Ifc_rel_flow_control_elements *o = new Ifc_rel_flow_control_elements();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_control_elements.push_back((Ifc_distribution_control_element *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_control_elements);
		o->relating_flow_element = (Ifc_distribution_flow_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_flow_element);
if (boost::iequals(object_class, "IfcRelInterferesElements")) {
		Ifc_rel_interferes_elements *o = new Ifc_rel_interferes_elements();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_element);
		o->related_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_element);
		o->interference_geometry = (Ifc_connection_geometry *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->interference_geometry);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//o->step_parser.parse_logical(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRelNests")) {
		Ifc_rel_nests *o = new Ifc_rel_nests();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_object = (Ifc_object_definition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_object);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_objects.push_back((Ifc_object_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_objects);
if (boost::iequals(object_class, "IfcRelProjectsElement")) {
		Ifc_rel_projects_element *o = new Ifc_rel_projects_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_element);
		o->related_feature_element = (Ifc_feature_element_addition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_feature_element);
if (boost::iequals(object_class, "IfcRelReferencedInSpatialStructure")) {
		Ifc_rel_referenced_in_spatial_structure *o = new Ifc_rel_referenced_in_spatial_structure();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_elements.push_back((Ifc_product *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_elements);
		o->relating_structure = (Ifc_spatial_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_structure);
if (boost::iequals(object_class, "IfcRelSequence")) {
		Ifc_rel_sequence *o = new Ifc_rel_sequence();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_process = (Ifc_process *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_process);
		o->related_process = (Ifc_process *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_process);
		o->time_lag = (Ifc_lag_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->time_lag);
		o->sequence_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcRelServicesBuildings")) {
		Ifc_rel_services_buildings *o = new Ifc_rel_services_buildings();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_system = (Ifc_system *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_system);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_buildings.push_back((Ifc_spatial_element *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_buildings);
if (boost::iequals(object_class, "IfcRelSpaceBoundary")) {
		Ifc_rel_space_boundary *o = new Ifc_rel_space_boundary();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_space = (Ifc_space_boundary_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_space);
		o->related_building_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_building_element);
		o->connection_geometry = (Ifc_connection_geometry *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->connection_geometry);
		o->physical_or_virtual_boundary = step_parser.parse_constant(object_attributes[%d]);
		o->internal_or_external_boundary = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRelSpaceBoundary1stLevel")) {
		Ifc_rel_space_boundary_1st_level *o = new Ifc_rel_space_boundary_1st_level();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_space = (Ifc_space_boundary_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_space);
		o->related_building_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_building_element);
		o->connection_geometry = (Ifc_connection_geometry *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->connection_geometry);
		o->physical_or_virtual_boundary = step_parser.parse_constant(object_attributes[%d]);
		o->internal_or_external_boundary = step_parser.parse_constant(object_attributes[%d]);
		o->parent_boundary = (Ifc_rel_space_boundary_1st_level *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->parent_boundary);
if (boost::iequals(object_class, "IfcRelSpaceBoundary2ndLevel")) {
		Ifc_rel_space_boundary_2nd_level *o = new Ifc_rel_space_boundary_2nd_level();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_space = (Ifc_space_boundary_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_space);
		o->related_building_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_building_element);
		o->connection_geometry = (Ifc_connection_geometry *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->connection_geometry);
		o->physical_or_virtual_boundary = step_parser.parse_constant(object_attributes[%d]);
		o->internal_or_external_boundary = step_parser.parse_constant(object_attributes[%d]);
		o->parent_boundary = (Ifc_rel_space_boundary_1st_level *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->parent_boundary);
		o->corresponding_boundary = (Ifc_rel_space_boundary_2nd_level *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->corresponding_boundary);
if (boost::iequals(object_class, "IfcRelVoidsElement")) {
		Ifc_rel_voids_element *o = new Ifc_rel_voids_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_building_element = (Ifc_element *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_building_element);
		o->related_opening_element = (Ifc_feature_element_subtraction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->related_opening_element);
if (boost::iequals(object_class, "IfcRelationship")) {
		Ifc_relationship *o = new Ifc_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcReparametrisedCompositeCurveSegment")) {
		Ifc_reparametrised_composite_curve_segment *o = new Ifc_reparametrised_composite_curve_segment();
		o->transition = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->parent_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->parent_curve);
		o->param_length = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRepresentation")) {
		Ifc_representation *o = new Ifc_representation();
		o->context_of_items = (Ifc_representation_context *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->context_of_items);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->items.push_back((Ifc_representation_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->items);
if (boost::iequals(object_class, "IfcRepresentationContext")) {
		Ifc_representation_context *o = new Ifc_representation_context();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcRepresentationItem")) {
		Ifc_representation_item *o = new Ifc_representation_item();
if (boost::iequals(object_class, "IfcRepresentationMap")) {
		Ifc_representation_map *o = new Ifc_representation_map();
		o->mapping_origin = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->mapping_origin);
		o->mapped_representation = (Ifc_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->mapped_representation);
if (boost::iequals(object_class, "IfcResource")) {
		Ifc_resource *o = new Ifc_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcResourceApprovalRelationship")) {
		Ifc_resource_approval_relationship *o = new Ifc_resource_approval_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_resource_objects.push_back((Ifc_resource_object_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_resource_objects);
		o->relating_approval = (Ifc_approval *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_approval);
if (boost::iequals(object_class, "IfcResourceConstraintRelationship")) {
		Ifc_resource_constraint_relationship *o = new Ifc_resource_constraint_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->relating_constraint = (Ifc_constraint *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->relating_constraint);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->related_resource_objects.push_back((Ifc_resource_object_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->related_resource_objects);
if (boost::iequals(object_class, "IfcResourceLevelRelationship")) {
		Ifc_resource_level_relationship *o = new Ifc_resource_level_relationship();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcResourceTime")) {
		Ifc_resource_time *o = new Ifc_resource_time();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->schedule_work = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
		o->schedule_start = step_parser.parse_string(object_attributes[%d]);
		o->schedule_finish = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->leveling_delay = step_parser.parse_string(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->status_time = step_parser.parse_string(object_attributes[%d]);
		o->actual_work = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
		o->actual_start = step_parser.parse_string(object_attributes[%d]);
		o->actual_finish = step_parser.parse_string(object_attributes[%d]);
		o->remaining_work = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
if (boost::iequals(object_class, "IfcRevolvedAreaSolid")) {
		Ifc_revolved_area_solid *o = new Ifc_revolved_area_solid();
		o->swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_area);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->axis = (Ifc_axis_1_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis);
		o->angle = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRevolvedAreaSolidTapered")) {
		Ifc_revolved_area_solid_tapered *o = new Ifc_revolved_area_solid_tapered();
		o->swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_area);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->axis = (Ifc_axis_1_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis);
		o->angle = step_parser.parse_double(object_attributes[%d]);
		o->end_swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->end_swept_area);
if (boost::iequals(object_class, "IfcRightCircularCone")) {
		Ifc_right_circular_cone *o = new Ifc_right_circular_cone();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcRightCircularCylinder")) {
		Ifc_right_circular_cylinder *o = new Ifc_right_circular_cylinder();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcRoof")) {
		Ifc_roof *o = new Ifc_roof();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRoofType")) {
		Ifc_roof_type *o = new Ifc_roof_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRoot")) {
		Ifc_root *o = new Ifc_root();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcRoundedRectangleProfileDef")) {
		Ifc_rounded_rectangle_profile_def *o = new Ifc_rounded_rectangle_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcSIUnit")) {
		Ifc_s_i_unit *o = new Ifc_s_i_unit();
		o->dimensions = (Ifc_dimensional_exponents *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->dimensions);
		o->unit_type = step_parser.parse_constant(object_attributes[%d]);
		o->prefix = step_parser.parse_constant(object_attributes[%d]);
		o->name = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSanitaryTerminal")) {
		Ifc_sanitary_terminal *o = new Ifc_sanitary_terminal();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSanitaryTerminalType")) {
		Ifc_sanitary_terminal_type *o = new Ifc_sanitary_terminal_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSchedulingTime")) {
		Ifc_scheduling_time *o = new Ifc_scheduling_time();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcSectionProperties")) {
		Ifc_section_properties *o = new Ifc_section_properties();
		o->section_type = step_parser.parse_constant(object_attributes[%d]);
		o->start_profile = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->start_profile);
		o->end_profile = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->end_profile);
if (boost::iequals(object_class, "IfcSectionReinforcementProperties")) {
		Ifc_section_reinforcement_properties *o = new Ifc_section_reinforcement_properties();
		o->longitudinal_start_position = step_parser.parse_double(object_attributes[%d]);
		o->longitudinal_end_position = step_parser.parse_double(object_attributes[%d]);
		o->transverse_position = step_parser.parse_double(object_attributes[%d]);
		o->reinforcement_role = step_parser.parse_constant(object_attributes[%d]);
		o->section_definition = (Ifc_section_properties *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->section_definition);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->cross_section_reinforcement_definitions.push_back((Ifc_reinforcement_bar_properties *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->cross_section_reinforcement_definitions);
if (boost::iequals(object_class, "IfcSectionedSpine")) {
		Ifc_sectioned_spine *o = new Ifc_sectioned_spine();
		o->spine_curve = (Ifc_composite_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->spine_curve);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->cross_sections.push_back((Ifc_profile_def *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->cross_sections);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->cross_section_positions.push_back((Ifc_axis_2_placement_3_d *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->cross_section_positions);
if (boost::iequals(object_class, "IfcSensor")) {
		Ifc_sensor *o = new Ifc_sensor();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSensorType")) {
		Ifc_sensor_type *o = new Ifc_sensor_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcShadingDevice")) {
		Ifc_shading_device *o = new Ifc_shading_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcShadingDeviceType")) {
		Ifc_shading_device_type *o = new Ifc_shading_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcShapeAspect")) {
		Ifc_shape_aspect *o = new Ifc_shape_aspect();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->shape_representations.push_back((Ifc_shape_model *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->shape_representations);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//o->step_parser.parse_logical(object_attributes[%d]);
		o->part_of_product_definition_shape = (Ifc_product_representation_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->part_of_product_definition_shape);
if (boost::iequals(object_class, "IfcShapeModel")) {
		Ifc_shape_model *o = new Ifc_shape_model();
		o->context_of_items = (Ifc_representation_context *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->context_of_items);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->items.push_back((Ifc_representation_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->items);
if (boost::iequals(object_class, "IfcShapeRepresentation")) {
		Ifc_shape_representation *o = new Ifc_shape_representation();
		o->context_of_items = (Ifc_representation_context *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->context_of_items);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->items.push_back((Ifc_representation_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->items);
if (boost::iequals(object_class, "IfcShellBasedSurfaceModel")) {
		Ifc_shell_based_surface_model *o = new Ifc_shell_based_surface_model();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->sbsm_boundary.push_back((Ifc_shell *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->sbsm_boundary);
if (boost::iequals(object_class, "IfcSimpleProperty")) {
		Ifc_simple_property *o = new Ifc_simple_property();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->description = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSimplePropertyTemplate")) {
		Ifc_simple_property_template *o = new Ifc_simple_property_template();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->template_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->enumerators = (Ifc_property_enumeration *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->enumerators);
		o->primary_unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->primary_unit);
		o->secondary_unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->secondary_unit);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->access_state = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSite")) {
		Ifc_site *o = new Ifc_site();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->composition_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef std::vector<int> Ifc_compound_plane_angle_measure;
		//TODO: parse non-pointer type: typedef std::vector<int> Ifc_compound_plane_angle_measure;
		o->ref_elevation = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->site_address = (Ifc_postal_address *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->site_address);
if (boost::iequals(object_class, "IfcSlab")) {
		Ifc_slab *o = new Ifc_slab();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSlabElementedCase")) {
		Ifc_slab_elemented_case *o = new Ifc_slab_elemented_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSlabStandardCase")) {
		Ifc_slab_standard_case *o = new Ifc_slab_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSlabType")) {
		Ifc_slab_type *o = new Ifc_slab_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSlippageConnectionCondition")) {
		Ifc_slippage_connection_condition *o = new Ifc_slippage_connection_condition();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->slippage_x = step_parser.parse_double(object_attributes[%d]);
		o->slippage_y = step_parser.parse_double(object_attributes[%d]);
		o->slippage_z = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSolarDevice")) {
		Ifc_solar_device *o = new Ifc_solar_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSolarDeviceType")) {
		Ifc_solar_device_type *o = new Ifc_solar_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSolidModel")) {
		Ifc_solid_model *o = new Ifc_solid_model();
if (boost::iequals(object_class, "IfcSpace")) {
		Ifc_space *o = new Ifc_space();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->composition_type = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->elevation_with_flooring = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSpaceHeater")) {
		Ifc_space_heater *o = new Ifc_space_heater();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSpaceHeaterType")) {
		Ifc_space_heater_type *o = new Ifc_space_heater_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSpaceType")) {
		Ifc_space_type *o = new Ifc_space_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcSpatialElement")) {
		Ifc_spatial_element *o = new Ifc_spatial_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcSpatialElementType")) {
		Ifc_spatial_element_type *o = new Ifc_spatial_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcSpatialStructureElement")) {
		Ifc_spatial_structure_element *o = new Ifc_spatial_structure_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->composition_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSpatialStructureElementType")) {
		Ifc_spatial_structure_element_type *o = new Ifc_spatial_structure_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcSpatialZone")) {
		Ifc_spatial_zone *o = new Ifc_spatial_zone();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSpatialZoneType")) {
		Ifc_spatial_zone_type *o = new Ifc_spatial_zone_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcSphere")) {
		Ifc_sphere *o = new Ifc_sphere();
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcStackTerminal")) {
		Ifc_stack_terminal *o = new Ifc_stack_terminal();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStackTerminalType")) {
		Ifc_stack_terminal_type *o = new Ifc_stack_terminal_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStair")) {
		Ifc_stair *o = new Ifc_stair();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStairFlight")) {
		Ifc_stair_flight *o = new Ifc_stair_flight();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->step_parser.parse_integer(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStairFlightType")) {
		Ifc_stair_flight_type *o = new Ifc_stair_flight_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStairType")) {
		Ifc_stair_type *o = new Ifc_stair_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralAction")) {
		Ifc_structural_action *o = new Ifc_structural_action();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralActivity")) {
		Ifc_structural_activity *o = new Ifc_structural_activity();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralAnalysisModel")) {
		Ifc_structural_analysis_model *o = new Ifc_structural_analysis_model();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->orientation_of_2_d_plane = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->orientation_of_2_d_plane);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->loaded_by.push_back((Ifc_structural_load_group *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->loaded_by);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_results.push_back((Ifc_structural_result_group *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_results);
		o->shared_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->shared_placement);
if (boost::iequals(object_class, "IfcStructuralConnection")) {
		Ifc_structural_connection *o = new Ifc_structural_connection();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_condition = (Ifc_boundary_condition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_condition);
if (boost::iequals(object_class, "IfcStructuralConnectionCondition")) {
		Ifc_structural_connection_condition *o = new Ifc_structural_connection_condition();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcStructuralCurveAction")) {
		Ifc_structural_curve_action *o = new Ifc_structural_curve_action();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->projected_or_true = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralCurveConnection")) {
		Ifc_structural_curve_connection *o = new Ifc_structural_curve_connection();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_condition = (Ifc_boundary_condition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_condition);
		o->axis = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis);
if (boost::iequals(object_class, "IfcStructuralCurveMember")) {
		Ifc_structural_curve_member *o = new Ifc_structural_curve_member();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->axis = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis);
if (boost::iequals(object_class, "IfcStructuralCurveMemberVarying")) {
		Ifc_structural_curve_member_varying *o = new Ifc_structural_curve_member_varying();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->axis = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis);
if (boost::iequals(object_class, "IfcStructuralCurveReaction")) {
		Ifc_structural_curve_reaction *o = new Ifc_structural_curve_reaction();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralItem")) {
		Ifc_structural_item *o = new Ifc_structural_item();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
if (boost::iequals(object_class, "IfcStructuralLinearAction")) {
		Ifc_structural_linear_action *o = new Ifc_structural_linear_action();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->projected_or_true = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralLoad")) {
		Ifc_structural_load *o = new Ifc_structural_load();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcStructuralLoadCase")) {
		Ifc_structural_load_case *o = new Ifc_structural_load_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->action_type = step_parser.parse_constant(object_attributes[%d]);
		o->action_source = step_parser.parse_constant(object_attributes[%d]);
		o->coefficient = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->self_weight_coefficients.push_back((Ifc_ratio_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->self_weight_coefficients);
if (boost::iequals(object_class, "IfcStructuralLoadConfiguration")) {
		Ifc_structural_load_configuration *o = new Ifc_structural_load_configuration();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->values.push_back((Ifc_structural_load_or_result *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->values);
				//TODO: parse container of container
if (boost::iequals(object_class, "IfcStructuralLoadGroup")) {
		Ifc_structural_load_group *o = new Ifc_structural_load_group();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->action_type = step_parser.parse_constant(object_attributes[%d]);
		o->action_source = step_parser.parse_constant(object_attributes[%d]);
		o->coefficient = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcStructuralLoadLinearForce")) {
		Ifc_structural_load_linear_force *o = new Ifc_structural_load_linear_force();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->linear_force_x = step_parser.parse_double(object_attributes[%d]);
		o->linear_force_y = step_parser.parse_double(object_attributes[%d]);
		o->linear_force_z = step_parser.parse_double(object_attributes[%d]);
		o->linear_moment_x = step_parser.parse_double(object_attributes[%d]);
		o->linear_moment_y = step_parser.parse_double(object_attributes[%d]);
		o->linear_moment_z = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralLoadOrResult")) {
		Ifc_structural_load_or_result *o = new Ifc_structural_load_or_result();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcStructuralLoadPlanarForce")) {
		Ifc_structural_load_planar_force *o = new Ifc_structural_load_planar_force();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->planar_force_x = step_parser.parse_double(object_attributes[%d]);
		o->planar_force_y = step_parser.parse_double(object_attributes[%d]);
		o->planar_force_z = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralLoadSingleDisplacement")) {
		Ifc_structural_load_single_displacement *o = new Ifc_structural_load_single_displacement();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->displacement_x = step_parser.parse_double(object_attributes[%d]);
		o->displacement_y = step_parser.parse_double(object_attributes[%d]);
		o->displacement_z = step_parser.parse_double(object_attributes[%d]);
		o->rotational_displacement_r_x = step_parser.parse_double(object_attributes[%d]);
		o->rotational_displacement_r_y = step_parser.parse_double(object_attributes[%d]);
		o->rotational_displacement_r_z = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralLoadSingleDisplacementDistortion")) {
		Ifc_structural_load_single_displacement_distortion *o = new Ifc_structural_load_single_displacement_distortion();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->displacement_x = step_parser.parse_double(object_attributes[%d]);
		o->displacement_y = step_parser.parse_double(object_attributes[%d]);
		o->displacement_z = step_parser.parse_double(object_attributes[%d]);
		o->rotational_displacement_r_x = step_parser.parse_double(object_attributes[%d]);
		o->rotational_displacement_r_y = step_parser.parse_double(object_attributes[%d]);
		o->rotational_displacement_r_z = step_parser.parse_double(object_attributes[%d]);
		o->distortion = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralLoadSingleForce")) {
		Ifc_structural_load_single_force *o = new Ifc_structural_load_single_force();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->force_x = step_parser.parse_double(object_attributes[%d]);
		o->force_y = step_parser.parse_double(object_attributes[%d]);
		o->force_z = step_parser.parse_double(object_attributes[%d]);
		o->moment_x = step_parser.parse_double(object_attributes[%d]);
		o->moment_y = step_parser.parse_double(object_attributes[%d]);
		o->moment_z = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralLoadSingleForceWarping")) {
		Ifc_structural_load_single_force_warping *o = new Ifc_structural_load_single_force_warping();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->force_x = step_parser.parse_double(object_attributes[%d]);
		o->force_y = step_parser.parse_double(object_attributes[%d]);
		o->force_z = step_parser.parse_double(object_attributes[%d]);
		o->moment_x = step_parser.parse_double(object_attributes[%d]);
		o->moment_y = step_parser.parse_double(object_attributes[%d]);
		o->moment_z = step_parser.parse_double(object_attributes[%d]);
		o->warping_moment = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralLoadStatic")) {
		Ifc_structural_load_static *o = new Ifc_structural_load_static();
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcStructuralLoadTemperature")) {
		Ifc_structural_load_temperature *o = new Ifc_structural_load_temperature();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->delta_t_constant = step_parser.parse_double(object_attributes[%d]);
		o->delta_t_y = step_parser.parse_double(object_attributes[%d]);
		o->delta_t_z = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralMember")) {
		Ifc_structural_member *o = new Ifc_structural_member();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
if (boost::iequals(object_class, "IfcStructuralPlanarAction")) {
		Ifc_structural_planar_action *o = new Ifc_structural_planar_action();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->projected_or_true = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralPointAction")) {
		Ifc_structural_point_action *o = new Ifc_structural_point_action();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralPointConnection")) {
		Ifc_structural_point_connection *o = new Ifc_structural_point_connection();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_condition = (Ifc_boundary_condition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_condition);
		o->condition_coordinate_system = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->condition_coordinate_system);
if (boost::iequals(object_class, "IfcStructuralPointReaction")) {
		Ifc_structural_point_reaction *o = new Ifc_structural_point_reaction();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralReaction")) {
		Ifc_structural_reaction *o = new Ifc_structural_reaction();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralResultGroup")) {
		Ifc_structural_result_group *o = new Ifc_structural_result_group();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->theory_type = step_parser.parse_constant(object_attributes[%d]);
		o->result_for_load_group = (Ifc_structural_load_group *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->result_for_load_group);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralSurfaceAction")) {
		Ifc_structural_surface_action *o = new Ifc_structural_surface_action();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->projected_or_true = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStructuralSurfaceConnection")) {
		Ifc_structural_surface_connection *o = new Ifc_structural_surface_connection();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_condition = (Ifc_boundary_condition *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_condition);
if (boost::iequals(object_class, "IfcStructuralSurfaceMember")) {
		Ifc_structural_surface_member *o = new Ifc_structural_surface_member();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcStructuralSurfaceMemberVarying")) {
		Ifc_structural_surface_member_varying *o = new Ifc_structural_surface_member_varying();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcStructuralSurfaceReaction")) {
		Ifc_structural_surface_reaction *o = new Ifc_structural_surface_reaction();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		o->applied_load = (Ifc_structural_load *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->applied_load);
		o->global_or_local = step_parser.parse_constant(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcStyleModel")) {
		Ifc_style_model *o = new Ifc_style_model();
		o->context_of_items = (Ifc_representation_context *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->context_of_items);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->items.push_back((Ifc_representation_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->items);
if (boost::iequals(object_class, "IfcStyledItem")) {
		Ifc_styled_item *o = new Ifc_styled_item();
		o->item = (Ifc_representation_item *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->item);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->styles.push_back((Ifc_style_assignment_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->styles);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcStyledRepresentation")) {
		Ifc_styled_representation *o = new Ifc_styled_representation();
		o->context_of_items = (Ifc_representation_context *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->context_of_items);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->items.push_back((Ifc_representation_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->items);
if (boost::iequals(object_class, "IfcSubContractResource")) {
		Ifc_sub_contract_resource *o = new Ifc_sub_contract_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		o->usage = (Ifc_resource_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->usage);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSubContractResourceType")) {
		Ifc_sub_contract_resource_type *o = new Ifc_sub_contract_resource_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->base_costs.push_back((Ifc_applied_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->base_costs);
		o->base_quantity = (Ifc_physical_quantity *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->base_quantity);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSubedge")) {
		Ifc_subedge *o = new Ifc_subedge();
		o->edge_start = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_start);
		o->edge_end = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->edge_end);
		o->parent_edge = (Ifc_edge *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->parent_edge);
if (boost::iequals(object_class, "IfcSurface")) {
		Ifc_surface *o = new Ifc_surface();
if (boost::iequals(object_class, "IfcSurfaceCurveSweptAreaSolid")) {
		Ifc_surface_curve_swept_area_solid *o = new Ifc_surface_curve_swept_area_solid();
		o->swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_area);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->directrix = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->directrix);
		o->start_param = step_parser.parse_double(object_attributes[%d]);
		o->end_param = step_parser.parse_double(object_attributes[%d]);
		o->reference_surface = (Ifc_surface *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->reference_surface);
if (boost::iequals(object_class, "IfcSurfaceFeature")) {
		Ifc_surface_feature *o = new Ifc_surface_feature();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSurfaceOfLinearExtrusion")) {
		Ifc_surface_of_linear_extrusion *o = new Ifc_surface_of_linear_extrusion();
		o->swept_curve = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_curve);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->extruded_direction = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->extruded_direction);
		o->depth = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSurfaceOfRevolution")) {
		Ifc_surface_of_revolution *o = new Ifc_surface_of_revolution();
		o->swept_curve = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_curve);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		o->axis_position = (Ifc_axis_1_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->axis_position);
if (boost::iequals(object_class, "IfcSurfaceReinforcementArea")) {
		Ifc_surface_reinforcement_area *o = new Ifc_surface_reinforcement_area();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->surface_reinforcement_1.push_back((Ifc_length_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->surface_reinforcement_1);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->surface_reinforcement_2.push_back((Ifc_length_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->surface_reinforcement_2);
		o->shear_reinforcement = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSurfaceStyle")) {
		Ifc_surface_style *o = new Ifc_surface_style();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->side = step_parser.parse_constant(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->styles.push_back((Ifc_surface_style_element_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->styles);
if (boost::iequals(object_class, "IfcSurfaceStyleLighting")) {
		Ifc_surface_style_lighting *o = new Ifc_surface_style_lighting();
		o->diffuse_transmission_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->diffuse_transmission_colour);
		o->diffuse_reflection_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->diffuse_reflection_colour);
		o->transmission_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->transmission_colour);
		o->reflectance_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->reflectance_colour);
if (boost::iequals(object_class, "IfcSurfaceStyleRefraction")) {
		Ifc_surface_style_refraction *o = new Ifc_surface_style_refraction();
		o->refraction_index = step_parser.parse_double(object_attributes[%d]);
		o->dispersion_factor = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSurfaceStyleRendering")) {
		Ifc_surface_style_rendering *o = new Ifc_surface_style_rendering();
		o->surface_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->surface_colour);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		o->diffuse_colour = (Ifc_colour_or_factor *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->diffuse_colour);
		o->transmission_colour = (Ifc_colour_or_factor *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->transmission_colour);
		o->diffuse_transmission_colour = (Ifc_colour_or_factor *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->diffuse_transmission_colour);
		o->reflection_colour = (Ifc_colour_or_factor *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->reflection_colour);
		o->specular_colour = (Ifc_colour_or_factor *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->specular_colour);
		o->specular_highlight = (Ifc_specular_highlight_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->specular_highlight);
		o->reflectance_method = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSurfaceStyleShading")) {
		Ifc_surface_style_shading *o = new Ifc_surface_style_shading();
		o->surface_colour = (Ifc_colour_rgb *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->surface_colour);
if (boost::iequals(object_class, "IfcSurfaceStyleWithTextures")) {
		Ifc_surface_style_with_textures *o = new Ifc_surface_style_with_textures();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->textures.push_back((Ifc_surface_texture *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->textures);
if (boost::iequals(object_class, "IfcSurfaceTexture")) {
		Ifc_surface_texture *o = new Ifc_surface_texture();
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->texture_transform = (Ifc_cartesian_transformation_operator_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->texture_transform);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->parameter.push_back((Ifc_identifier *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->parameter);
if (boost::iequals(object_class, "IfcSweptAreaSolid")) {
		Ifc_swept_area_solid *o = new Ifc_swept_area_solid();
		o->swept_area = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_area);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
if (boost::iequals(object_class, "IfcSweptDiskSolid")) {
		Ifc_swept_disk_solid *o = new Ifc_swept_disk_solid();
		o->directrix = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->directrix);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->start_param = step_parser.parse_double(object_attributes[%d]);
		o->end_param = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSweptDiskSolidPolygonal")) {
		Ifc_swept_disk_solid_polygonal *o = new Ifc_swept_disk_solid_polygonal();
		o->directrix = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->directrix);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->start_param = step_parser.parse_double(object_attributes[%d]);
		o->end_param = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcSweptSurface")) {
		Ifc_swept_surface *o = new Ifc_swept_surface();
		o->swept_curve = (Ifc_profile_def *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->swept_curve);
		o->position = (Ifc_axis_2_placement_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
if (boost::iequals(object_class, "IfcSwitchingDevice")) {
		Ifc_switching_device *o = new Ifc_switching_device();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSwitchingDeviceType")) {
		Ifc_switching_device_type *o = new Ifc_switching_device_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSystem")) {
		Ifc_system *o = new Ifc_system();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcSystemFurnitureElement")) {
		Ifc_system_furniture_element *o = new Ifc_system_furniture_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcSystemFurnitureElementType")) {
		Ifc_system_furniture_element_type *o = new Ifc_system_furniture_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTShapeProfileDef")) {
		Ifc_t_shape_profile_def *o = new Ifc_t_shape_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->web_slope = step_parser.parse_double(object_attributes[%d]);
		o->flange_slope = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTable")) {
		Ifc_table *o = new Ifc_table();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->rows.push_back((Ifc_table_row *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->rows);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->columns.push_back((Ifc_table_column *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->columns);
if (boost::iequals(object_class, "IfcTableColumn")) {
		Ifc_table_column *o = new Ifc_table_column();
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
		o->reference_path = (Ifc_reference *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->reference_path);
if (boost::iequals(object_class, "IfcTableRow")) {
		Ifc_table_row *o = new Ifc_table_row();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->row_cells.push_back((Ifc_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->row_cells);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTank")) {
		Ifc_tank *o = new Ifc_tank();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTankType")) {
		Ifc_tank_type *o = new Ifc_tank_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTask")) {
		Ifc_task *o = new Ifc_task();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->step_parser.parse_integer(object_attributes[%d]);
		o->task_time = (Ifc_task_time *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->task_time);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTaskTime")) {
		Ifc_task_time *o = new Ifc_task_time();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->duration_type = step_parser.parse_constant(object_attributes[%d]);
		o->schedule_duration = step_parser.parse_string(object_attributes[%d]);
		o->schedule_start = step_parser.parse_string(object_attributes[%d]);
		o->schedule_finish = step_parser.parse_string(object_attributes[%d]);
		o->early_start = step_parser.parse_string(object_attributes[%d]);
		o->early_finish = step_parser.parse_string(object_attributes[%d]);
		o->late_start = step_parser.parse_string(object_attributes[%d]);
		o->late_finish = step_parser.parse_string(object_attributes[%d]);
		o->free_float = step_parser.parse_string(object_attributes[%d]);
		o->total_float = step_parser.parse_string(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->status_time = step_parser.parse_string(object_attributes[%d]);
		o->actual_duration = step_parser.parse_string(object_attributes[%d]);
		o->actual_start = step_parser.parse_string(object_attributes[%d]);
		o->actual_finish = step_parser.parse_string(object_attributes[%d]);
		o->remaining_time = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
if (boost::iequals(object_class, "IfcTaskTimeRecurring")) {
		Ifc_task_time_recurring *o = new Ifc_task_time_recurring();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->duration_type = step_parser.parse_constant(object_attributes[%d]);
		o->schedule_duration = step_parser.parse_string(object_attributes[%d]);
		o->schedule_start = step_parser.parse_string(object_attributes[%d]);
		o->schedule_finish = step_parser.parse_string(object_attributes[%d]);
		o->early_start = step_parser.parse_string(object_attributes[%d]);
		o->early_finish = step_parser.parse_string(object_attributes[%d]);
		o->late_start = step_parser.parse_string(object_attributes[%d]);
		o->late_finish = step_parser.parse_string(object_attributes[%d]);
		o->free_float = step_parser.parse_string(object_attributes[%d]);
		o->total_float = step_parser.parse_string(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->status_time = step_parser.parse_string(object_attributes[%d]);
		o->actual_duration = step_parser.parse_string(object_attributes[%d]);
		o->actual_start = step_parser.parse_string(object_attributes[%d]);
		o->actual_finish = step_parser.parse_string(object_attributes[%d]);
		o->remaining_time = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_positive_ratio_measure;
		o->recurrance = (Ifc_recurrence_pattern *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->recurrance);
if (boost::iequals(object_class, "IfcTaskType")) {
		Ifc_task_type *o = new Ifc_task_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcTelecomAddress")) {
		Ifc_telecom_address *o = new Ifc_telecom_address();
		o->purpose = step_parser.parse_constant(object_attributes[%d]);
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->telephone_numbers.push_back((Ifc_label *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->telephone_numbers);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->facsimile_numbers.push_back((Ifc_label *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->facsimile_numbers);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->electronic_mail_addresses.push_back((Ifc_label *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->electronic_mail_addresses);
		o->w_w_w_home_page_u_r_l = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->messaging_i_ds.push_back((Ifc_u_r_i_reference *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->messaging_i_ds);
if (boost::iequals(object_class, "IfcTendon")) {
		Ifc_tendon *o = new Ifc_tendon();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->cross_section_area = step_parser.parse_double(object_attributes[%d]);
		o->tension_force = step_parser.parse_double(object_attributes[%d]);
		o->pre_stress = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcTendonAnchor")) {
		Ifc_tendon_anchor *o = new Ifc_tendon_anchor();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTendonAnchorType")) {
		Ifc_tendon_anchor_type *o = new Ifc_tendon_anchor_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTendonType")) {
		Ifc_tendon_type *o = new Ifc_tendon_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->cross_section_area = step_parser.parse_double(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
if (boost::iequals(object_class, "IfcTessellatedFaceSet")) {
		Ifc_tessellated_face_set *o = new Ifc_tessellated_face_set();
		o->coordinates = (Ifc_cartesian_point_list_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->coordinates);
				//TODO: parse container of container
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTessellatedItem")) {
		Ifc_tessellated_item *o = new Ifc_tessellated_item();
if (boost::iequals(object_class, "IfcTextLiteral")) {
		Ifc_text_literal *o = new Ifc_text_literal();
		o->literal = step_parser.parse_string(object_attributes[%d]);
		o->placement = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->placement);
		o->path = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTextLiteralWithExtent")) {
		Ifc_text_literal_with_extent *o = new Ifc_text_literal_with_extent();
		o->literal = step_parser.parse_string(object_attributes[%d]);
		o->placement = (Ifc_axis_2_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->placement);
		o->path = step_parser.parse_constant(object_attributes[%d]);
		o->extent = (Ifc_planar_extent *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->extent);
		//TODO: parse non-pointer type: typedef Ifc_label Ifc_box_alignment;
if (boost::iequals(object_class, "IfcTextStyle")) {
		Ifc_text_style *o = new Ifc_text_style();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->text_character_appearance = (Ifc_text_style_for_defined_font *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->text_character_appearance);
		o->text_style = (Ifc_text_style_text_model *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->text_style);
		o->text_font_style = (Ifc_text_font_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->text_font_style);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTextStyleFontModel")) {
		Ifc_text_style_font_model *o = new Ifc_text_style_font_model();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->font_family.push_back((Ifc_text_font_name *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->font_family);
		o->font_style = step_parser.parse_string(object_attributes[%d]);
		o->font_variant = step_parser.parse_string(object_attributes[%d]);
		o->font_weight = step_parser.parse_string(object_attributes[%d]);
		o->font_size = (Ifc_size_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->font_size);
if (boost::iequals(object_class, "IfcTextStyleForDefinedFont")) {
		Ifc_text_style_for_defined_font *o = new Ifc_text_style_for_defined_font();
		o->colour = (Ifc_colour *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->colour);
		o->background_colour = (Ifc_colour *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->background_colour);
if (boost::iequals(object_class, "IfcTextStyleTextModel")) {
		Ifc_text_style_text_model *o = new Ifc_text_style_text_model();
		o->text_indent = (Ifc_size_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->text_indent);
		o->text_align = step_parser.parse_string(object_attributes[%d]);
		o->text_decoration = step_parser.parse_string(object_attributes[%d]);
		o->letter_spacing = (Ifc_size_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->letter_spacing);
		o->word_spacing = (Ifc_size_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->word_spacing);
		o->text_transform = step_parser.parse_string(object_attributes[%d]);
		o->line_height = (Ifc_size_select *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->line_height);
if (boost::iequals(object_class, "IfcTextureCoordinate")) {
		Ifc_texture_coordinate *o = new Ifc_texture_coordinate();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->maps.push_back((Ifc_surface_texture *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->maps);
if (boost::iequals(object_class, "IfcTextureCoordinateGenerator")) {
		Ifc_texture_coordinate_generator *o = new Ifc_texture_coordinate_generator();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->maps.push_back((Ifc_surface_texture *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->parameter.push_back((Ifc_real *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->parameter);
if (boost::iequals(object_class, "IfcTextureMap")) {
		Ifc_texture_map *o = new Ifc_texture_map();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->maps.push_back((Ifc_surface_texture *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->maps);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->vertices.push_back((Ifc_texture_vertex *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->vertices);
		o->mapped_to = (Ifc_face *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->mapped_to);
if (boost::iequals(object_class, "IfcTextureVertex")) {
		Ifc_texture_vertex *o = new Ifc_texture_vertex();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->coordinates.push_back((Ifc_parameter_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->coordinates);
if (boost::iequals(object_class, "IfcTextureVertexList")) {
		Ifc_texture_vertex_list *o = new Ifc_texture_vertex_list();
				//TODO: parse container of container
if (boost::iequals(object_class, "IfcTimePeriod")) {
		Ifc_time_period *o = new Ifc_time_period();
		o->start_time = step_parser.parse_string(object_attributes[%d]);
		o->end_time = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTimeSeries")) {
		Ifc_time_series *o = new Ifc_time_series();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->start_time = step_parser.parse_string(object_attributes[%d]);
		o->end_time = step_parser.parse_string(object_attributes[%d]);
		o->time_series_data_type = step_parser.parse_constant(object_attributes[%d]);
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->unit = (Ifc_unit *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->unit);
if (boost::iequals(object_class, "IfcTimeSeriesValue")) {
		Ifc_time_series_value *o = new Ifc_time_series_value();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->list_values.push_back((Ifc_value *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->list_values);
if (boost::iequals(object_class, "IfcTopologicalRepresentationItem")) {
		Ifc_topological_representation_item *o = new Ifc_topological_representation_item();
if (boost::iequals(object_class, "IfcTopologyRepresentation")) {
		Ifc_topology_representation *o = new Ifc_topology_representation();
		o->context_of_items = (Ifc_representation_context *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->context_of_items);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->items.push_back((Ifc_representation_item *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->items);
if (boost::iequals(object_class, "IfcTransformer")) {
		Ifc_transformer *o = new Ifc_transformer();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTransformerType")) {
		Ifc_transformer_type *o = new Ifc_transformer_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTransportElement")) {
		Ifc_transport_element *o = new Ifc_transport_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTransportElementType")) {
		Ifc_transport_element_type *o = new Ifc_transport_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTrapeziumProfileDef")) {
		Ifc_trapezium_profile_def *o = new Ifc_trapezium_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->top_x_offset = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTriangulatedFaceSet")) {
		Ifc_triangulated_face_set *o = new Ifc_triangulated_face_set();
		o->coordinates = (Ifc_cartesian_point_list_3_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->coordinates);
				//TODO: parse container of container
		o->step_parser.parse_boolean(object_attributes[%d]);
				//TODO: parse container of container
				//TODO: parse container of container
if (boost::iequals(object_class, "IfcTrimmedCurve")) {
		Ifc_trimmed_curve *o = new Ifc_trimmed_curve();
		o->basis_curve = (Ifc_curve *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->basis_curve);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->trim_1.push_back((Ifc_trimming_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->trim_1);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->trim_2.push_back((Ifc_trimming_select *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->trim_2);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->master_representation = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTubeBundle")) {
		Ifc_tube_bundle *o = new Ifc_tube_bundle();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTubeBundleType")) {
		Ifc_tube_bundle_type *o = new Ifc_tube_bundle_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcTypeObject")) {
		Ifc_type_object *o = new Ifc_type_object();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
if (boost::iequals(object_class, "IfcTypeProcess")) {
		Ifc_type_process *o = new Ifc_type_process();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcTypeProduct")) {
		Ifc_type_product *o = new Ifc_type_product();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcTypeResource")) {
		Ifc_type_resource *o = new Ifc_type_resource();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->long_description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcUShapeProfileDef")) {
		Ifc_u_shape_profile_def *o = new Ifc_u_shape_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		o->flange_slope = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcUnitAssignment")) {
		Ifc_unit_assignment *o = new Ifc_unit_assignment();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->units.push_back((Ifc_unit *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->units);
if (boost::iequals(object_class, "IfcUnitaryControlElement")) {
		Ifc_unitary_control_element *o = new Ifc_unitary_control_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcUnitaryControlElementType")) {
		Ifc_unitary_control_element_type *o = new Ifc_unitary_control_element_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcUnitaryEquipment")) {
		Ifc_unitary_equipment *o = new Ifc_unitary_equipment();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcUnitaryEquipmentType")) {
		Ifc_unitary_equipment_type *o = new Ifc_unitary_equipment_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcValve")) {
		Ifc_valve *o = new Ifc_valve();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcValveType")) {
		Ifc_valve_type *o = new Ifc_valve_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcVector")) {
		Ifc_vector *o = new Ifc_vector();
		o->orientation = (Ifc_direction *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->orientation);
		o->magnitude = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcVertex")) {
		Ifc_vertex *o = new Ifc_vertex();
if (boost::iequals(object_class, "IfcVertexLoop")) {
		Ifc_vertex_loop *o = new Ifc_vertex_loop();
		o->loop_vertex = (Ifc_vertex *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->loop_vertex);
if (boost::iequals(object_class, "IfcVertexPoint")) {
		Ifc_vertex_point *o = new Ifc_vertex_point();
		o->vertex_geometry = (Ifc_point *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->vertex_geometry);
if (boost::iequals(object_class, "IfcVibrationIsolator")) {
		Ifc_vibration_isolator *o = new Ifc_vibration_isolator();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcVibrationIsolatorType")) {
		Ifc_vibration_isolator_type *o = new Ifc_vibration_isolator_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcVirtualElement")) {
		Ifc_virtual_element *o = new Ifc_virtual_element();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
if (boost::iequals(object_class, "IfcVirtualGridIntersection")) {
		Ifc_virtual_grid_intersection *o = new Ifc_virtual_grid_intersection();
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->intersecting_axes.push_back((Ifc_grid_axis *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->intersecting_axes);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->offset_distances.push_back((Ifc_length_measure *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->offset_distances);
if (boost::iequals(object_class, "IfcVoidingFeature")) {
		Ifc_voiding_feature *o = new Ifc_voiding_feature();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWall")) {
		Ifc_wall *o = new Ifc_wall();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWallElementedCase")) {
		Ifc_wall_elemented_case *o = new Ifc_wall_elemented_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWallStandardCase")) {
		Ifc_wall_standard_case *o = new Ifc_wall_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWallType")) {
		Ifc_wall_type *o = new Ifc_wall_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWasteTerminal")) {
		Ifc_waste_terminal *o = new Ifc_waste_terminal();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWasteTerminalType")) {
		Ifc_waste_terminal_type *o = new Ifc_waste_terminal_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWindow")) {
		Ifc_window *o = new Ifc_window();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->partitioning_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcWindowLiningProperties")) {
		Ifc_window_lining_properties *o = new Ifc_window_lining_properties();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		//TODO: parse non-pointer type: typedef Ifc_ratio_measure Ifc_normalised_ratio_measure;
		o->shape_aspect_style = (Ifc_shape_aspect *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->shape_aspect_style);
		o->lining_offset = step_parser.parse_double(object_attributes[%d]);
		o->lining_to_panel_offset_x = step_parser.parse_double(object_attributes[%d]);
		o->lining_to_panel_offset_y = step_parser.parse_double(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWindowPanelProperties")) {
		Ifc_window_panel_properties *o = new Ifc_window_panel_properties();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		o->operation_type = step_parser.parse_constant(object_attributes[%d]);
		o->panel_position = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->shape_aspect_style = (Ifc_shape_aspect *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->shape_aspect_style);
if (boost::iequals(object_class, "IfcWindowStandardCase")) {
		Ifc_window_standard_case *o = new Ifc_window_standard_case();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->object_placement = (Ifc_object_placement *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->object_placement);
		o->representation = (Ifc_product_representation *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->representation);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->partitioning_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcWindowStyle")) {
		Ifc_window_style *o = new Ifc_window_style();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->construction_type = step_parser.parse_constant(object_attributes[%d]);
		o->operation_type = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWindowType")) {
		Ifc_window_type *o = new Ifc_window_type();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->has_property_sets.push_back((Ifc_property_set_definition *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->has_property_sets);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->representation_maps.push_back((Ifc_representation_map *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->representation_maps);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
		o->partitioning_type = step_parser.parse_constant(object_attributes[%d]);
		o->step_parser.parse_boolean(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
if (boost::iequals(object_class, "IfcWorkCalendar")) {
		Ifc_work_calendar *o = new Ifc_work_calendar();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->working_times.push_back((Ifc_work_time *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->working_times);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->exception_times.push_back((Ifc_work_time *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->exception_times);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWorkControl")) {
		Ifc_work_control *o = new Ifc_work_control();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->creation_date = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->creators.push_back((Ifc_person *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->creators);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->duration = step_parser.parse_string(object_attributes[%d]);
		o->total_float = step_parser.parse_string(object_attributes[%d]);
		o->start_time = step_parser.parse_string(object_attributes[%d]);
		o->finish_time = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWorkPlan")) {
		Ifc_work_plan *o = new Ifc_work_plan();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->creation_date = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->creators.push_back((Ifc_person *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->creators);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->duration = step_parser.parse_string(object_attributes[%d]);
		o->total_float = step_parser.parse_string(object_attributes[%d]);
		o->start_time = step_parser.parse_string(object_attributes[%d]);
		o->finish_time = step_parser.parse_string(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWorkSchedule")) {
		Ifc_work_schedule *o = new Ifc_work_schedule();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_identifier;
		o->creation_date = step_parser.parse_string(object_attributes[%d]);
		for (auto i : step_parser.parse_list_of_links(object_attributes[%d])) o->creators.push_back((Ifc_person *)i);
lists_of_links_to_resolve.push_back((std::vector<Ifc *> *)&o->creators);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->duration = step_parser.parse_string(object_attributes[%d]);
		o->total_float = step_parser.parse_string(object_attributes[%d]);
		o->start_time = step_parser.parse_string(object_attributes[%d]);
		o->finish_time = step_parser.parse_string(object_attributes[%d]);
		o->predefined_type = step_parser.parse_constant(object_attributes[%d]);
if (boost::iequals(object_class, "IfcWorkTime")) {
		Ifc_work_time *o = new Ifc_work_time();
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->data_origin = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->recurrence_pattern = (Ifc_recurrence_pattern *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->recurrence_pattern);
		o->start = step_parser.parse_string(object_attributes[%d]);
		o->finish = step_parser.parse_string(object_attributes[%d]);
if (boost::iequals(object_class, "IfcZShapeProfileDef")) {
		Ifc_z_shape_profile_def *o = new Ifc_z_shape_profile_def();
		o->profile_type = step_parser.parse_constant(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->position = (Ifc_axis_2_placement_2_d *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->position);
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_positive_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
		//TODO: parse non-pointer type: typedef Ifc_length_measure Ifc_non_negative_length_measure;
if (boost::iequals(object_class, "IfcZone")) {
		Ifc_zone *o = new Ifc_zone();
		//TODO: parse non-pointer type: typedef  Ifc_globally_unique_id;
		o->owner_history = (Ifc_owner_history *)step_parser.parse_link(object_attributes[%d]);
links_to_resolve.push_back((Ifc **)&o->owner_history);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		o->description = step_parser.parse_string(object_attributes[%d]);
		//TODO: parse non-pointer type: typedef  Ifc_label;
		//TODO: parse non-pointer type: typedef  Ifc_label;
